\chapter{Implementierung}

Es gibt viele verschiedene Spielprinzipien und daher sollte soweit es geht mit
der PTPLibrary den späteren Entwicklern so viel Freiheit gelassen werden wie
möglich.
Jedoch gibt es viele Abläufe, die sich immer wieder wiederholen. So hat man den
typschen Ablauf, dass man das Spiel startet und man sich in einer Lobby
befindet. Danach kann man entweder ein Spiel erstellen und sich zu einem bereits
erstellten Spiel verbinden. Diesen Ablauf wird durch die PTPLibrary
übernommen, sodass man sich hinterher darum nicht mehr kümmern muss.
Der Entwickler hätte dann nur noch die Aufgabe sich um die Activities zu
kümmern, die das Spiel representieren und die Verbindung und Vermittlung würde
die PTPLibrary übernehmen. Um das Bibliothek benutzen zu können müsste der
Entwickler dann die PTPLibrary als Bibliothek in sein Projekt einbinden und er
könnte loslegen. 

\section{PTPHelper}
Der PTPHelper ist eine Schnittstelle zwischen dem Spiel und
dem Hintergrundservice, welcher sich um die Verbindung kümmert.
Nach Abwägen mehrerer Möglichkeiten wie man den Service, welcher sich um die
Verbindungstechnischen Abläufe kümmert, in die Applikation integrieren kann, ist
die Wahl schließlich auf die Benutzung eines Singletons gefallen. Zwar ließe
sich eine abstrakte Application benutzen, die der Entwickler in seinem Projekt
implementieren müsste, aber dies würde dem Entwickler auch eine
Architekturentscheidung aufzwingen. Außerdem ist eine zu enge Bindung an das
Android Rahmenwerk unvorteilhaft, da sich dessen API recht oft ändert und die
Entwicklung in der Zukunft erschweren kann. Durch das Singleton kann der
Entwickler entscheiden, wann er den Service startet und wie er damit
interagieren will. So kann er z.B.
den Einzelspielermodus vollkommen ohne der Benutzung des PTPHelpers realisieren
und erst bei Multiplayermodus den Service starten. Um den PTPHelper zu
initialisieren muss der Entwickler in seinem Code den folgenden Befehl aus dem
Codeausschnitt ~\ref{initHelper} ausführen.\newpage

\begin{lstlisting}[caption=Helper initialisieren,label=initHelper]
PTPHelper.initHelper(MyInterface.class, context, proxyObject, signalHandler, MyLobby.class);
\end{lstlisting}

Daraufhin kann er über den Getter an die initialisierte Instanz kommen, wie im
Codeausschnitt ~\ref{getInstance} gezeigt.
\begin{lstlisting}[caption=Getter für die initialisierte Instanz,label=getInstance] 
PTPHelper.getInstance();
\end{lstlisting}
Man muss jedoch beachten, das der Hintergrundservice noch nicht vollständig
gestartet werden kann, da es sich hierbei um einen asynchronen Ablauf handelt.
Um den Zustand des Hintergrundservices zu erfahren kann man über den
Methodenaufruf, wie im Codeausschnitt ~\ref{connectionState} gezeigt, erfragen.
\begin{lstlisting}[caption=Verbindungstatus erfragen,label=connectionState]
PTPHelper.getIntance().getConnectionState();
\end{lstlisting}
Dabei handelt es sich um einen Integer, welcher die Werte CONNECTED=7
und DISCONNECTED=8 annehmen kann. Bei der Initialisierung wird der P2PService im
Hintergrund gestartet welcher die Verbindung zum Bussystem aufbaut, daher sind die ganzen Parameter notwendig. Es wird zum einen die Interface Klasse benötigt über das die Kommunikation mit den anderen Peers realisiert wird und gibt den Typ für die generische P2PHelper Klasse vor.
Der context ist die Activity oder die Application an die der Service gebunden wird. 
Der MyLobby.class Paramater übergibt die Klasse, die die AbstractLobbyActivity
aus dem PTPRahmenwerk implementiert. Die LobbyActivity ist an den Service
gebunden, da sie über den Zustand der Verbindung benachrichtigt wird. Die
genauere Funktionalität der Lobby wird später noch erklärt. Das ProxyObject und
der SignalHandler müssen gleich bei der Initialisierung übergeben werden, da sie
bei der Verbindung mit dem Bus beim Bus registriert werden müssen, damit sie
gleich auf Nachrichten reagieren können und das ProxyObject gleich einem
konkreten Endpunkt zugewiesen werden kann.
Damit der Service nur so lange läuft wie die Application wird der Service
gebunden an diese gebunden, siehe Codeausschnitt ~\ref{bindService}.\newpage

\begin{lstlisting}[caption=Service binden,label=bindService]
Intent service = new Intent(context,PTPService.class);
boolean bound = context.bindService(service,new PTPServiceConnection(),Service.BIND_AUTO_CREATE);
\end{lstlisting}
Bei dem PTPServiceConnection Objekt handelt es sich im Grunde nur um einen
Listener, welcher benachrichtigt wird, wenn die Verbindung zum Service aufgebaut
oder getrennt ist. Der Flag \ib{Service.BIND\_AUTO\_CREATE}
besagt, dass nach dem Binden des Services der Service automatisch über die
Methode \ib{onCreate()} erstellt werden soll.

Die PTPLibrary ist dazu ausgelegt nur im WLAN zu funkionieren, somit wird bei
der Initialisierung geprüft ob das Gerät über eine WiFi Verbindung verfügt.
Dies wird über den WiFiManager realisiert, wie im Codeausschnitt
~\ref{wifiManager} dargestellt.
\begin{lstlisting}[caption=WifiManager,label=wifiManager]
WifiManager wifiManager =(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
WifiInfo currentWifi = wifiManager.getConnectionInfo(); 
if((currentWifi==null || currentWifi.getSSID()== null || currentWifi.getSSID().isEmpty()){
	//Zeige, dass es keine WiFi Verbindung gibt
}
\end{lstlisting}
Im Falle dessen, dass es keine WiFi-Verbindung gibt, wird die Initialisierung
abgebrochen und der Service wird nicht gestartet.
Android ermöglicht es zusätzlich ein AccessPoint zu erstellen, worüber sich
andere Geräte verbinden können. Die Information über diesen Zustand wird jedoch
nicht ohne Weiteres über den WiFi-Mananger herausgegeben, sodass man an diese
Information nur über Java-Reflection gelangt. Wie das funktioniert wird im
Codebeispiel ~\ref{reflect} verdeutlicht.

\begin{lstlisting}[caption=Access Point Status erfragen,label=reflect]
Method method = wifiManager.getClass().getMethod("isWifiApEnabled");
state = (Boolean) method.invoke(wifiManager);
\end{lstlisting}
Nach dem jedoch der Helper initialisiert ist und der Service gestartet, kann man
über den Helper den Service mitteilen sich z.B. zu einem Channel zu verbinden
oder einen Channel zu erstellen.
Dies geschickt über einfache Methodenaufrufe, wie im Beispiel ~\ref{clientHost}
gezeigt.

\begin{lstlisting}[caption=Host/Client Sessions Handhabung,label=clientHost]
//Host
PTPHelper.getInstance().setHostChannelName(name)
PTPHelper.getInstance().hostStartChannel()
...
//Client
PTPHelper.getInstance().setClientChannelName("channelName");
PTPHelper.getInstance().joinChannel();
\end{lstlisting}

Der PTPHelper erlaubt es zusätzlich verschiedene Observer zu registrieren um auf
möglichliche Events entsprechend reagieren zu können.
Zu den Observern gehören die Interfaces LobbyObserver, BusObserver,
SessionObserver und der HelperObserver, welche der Entwickler selber Implementieren kann.
Zu den LobbyObservern gehört z.B. auch die AbstractLobbyActivity und
implementiert die Methode \ib{conncetionStateChanged(int state)},
welche aufgerufen wird, wenn der Service eine Verbindung aufbaut oder trennt.
Der BusObserver hört auf den Bus selbst und definiert die folgenden Methoden:
\begin{lstlisting}[caption=BusObserver]
public void foundAdvertisedName(String channelName);
public void lostAdvertisedName(String channelName);
public void busDisconnected();
\end{lstlisting}
Dadurch kann man zusätzlich noch auf das Öffnen und Schließen der Spiele
reagieren, falls die in der PTPLibrary vorimplementierte Behandlung, für den
Entwickler nicht ausreichend ist. Die \ib{foundAdvertisedName} Methode wird
aufgerufen, wenn eine neue Session gefunden wurde und \ib{lostAdvertisedName}
wenn eine bekannte Session geschlossen wurde oder nicht mehr erreichbar ist.
Die \ib{busDisconnected} Methode wird aufgerufen, wenn das BusAttachement
keine Verbindung zum Bus mehr hat. Der BusObserver ist z.B.
im PTPHelper schon einmal implementiert und er sorgt dafür, dass neu erstellte Spiele in einer Liste
\ib{foundChannels} gespeichert werden und entsprechend auch
entfernt. Dies ist notwendig um in der Lobby alle gerade offenen Spiele anzeigen
zu können.
\newline
Der SessionObserver definiert Methoden um auf Events zu reagieren,
die im Bezug zu einer Session stehen. Der Codeausschnitt ~\ref{sessionObserver}
zeigt die Methoden, welche das Interface definiert.
\newpage
\begin{lstlisting}[caption=SessionObserver,label=sessionObserver]
public void memberJoined(String uniqueId);
public void memberLeft(String uniqueId);
public void sessionLost();
\end{lstlisting}
Dies ermöglicht es dem Entwickler bestimmte Aktionen auszuführen, falls neue
Spieler sich zur Session verbinden \ib{(memberJoined)}, sich von der Session
trennen \ib{(memberLeft)} oder man selbst die Verbindung zur Session verliert
\ib{(sessionLost)}. Schließlich gibt es noch den \ib{ServiceHelperObserver},
welcher z.B.vom PTPService implementiert wird. Dieser Observer hört auf den
Helper, welcher über die Methode \ib{doAction(int action)} verschieden Aktionen
mitteilt, die über den Helper ausgeführt werden. So hat z.B. der Methodenaufruf
aus Codeausschnitt ~\ref{joinChannel}
\begin{lstlisting}[caption=verbinde zur Session,label=joinChannel]
PTPHelper.getInstance().joinChannel();
\end{lstlisting}
zur Folge, dass der PTPHelper den Service über den Observer mitteilt sich zu
einem Channel zu verbinden, was im Genaueren so aussieht der Codeausschnitt
~\ref{joinChannel2}
\begin{lstlisting}[caption=JoinSession,label=joinChannel2]
public synchronized void joinChannel() {
	notifyHelperObservers(PTPService.JOIN_SESSION);
}
\end{lstlisting}
Die oben genannten Observer sind mithilfe eines \ib{Handlers} vom
Hintergrundthread abgekoppelt. Dies verhindert, dass der Entwickler bei der
Implementierung der Observer sich kaum Gedanken um Threadkollisionen machen
muss.
Der PTPHelper besitzt nämlich einen \ib{BackgroundHandler}, welcher im
Konstruktor erstellt und an den UI Thread gekoppelt wird, siehe Codeausschnitt 
~\ref{uiBackgroundThread}.
\begin{lstlisting}[caption=UI Thread BackgroundHandler,label=uiBackgroundThread]
backgroundHandler = new BackgroundHandler(Looper.getMainLooper());
\end{lstlisting}
Sobald der Hintergrundprozess aus dem PTPService die Observer benachrichtigen
will und z.B. die Methode \ib{notifyMemberJoined(String)} ausführt, wird diese
Nachricht an den \ib{BackgroundHandler} geleitet, wie das funktioniert zeigt
der Codeausschnitt ~\ref{forwardMessage}.
\begin{lstlisting}[caption=Nachricht an den BackgroundHandler leiten,label=forwardMessage] 
Message obtainedMessage = backgroundHandler.obtainMessage(BackgroundHandler.MEMBER_JOINED, membersId); 
backgroundHandler.sendMessage(obtainedMessage);	
\end{lstlisting}
Der \ib{BackgroundHandler} reagiert über die Methode
\ib{handleMessage(Message)} auf die Nachricht, indem jedoch die Methode auf dem
UI Thread ausgeführt wird.

Dann gibt es noch das \ib{SessionJoinRule} Interface, welches
die \ib{boolean canJoin(String joinersUniqueId)} Methode definiert.
Darüber kann der Entwickler bestimmte Regeln festlegen, die darüber entscheiden
ob ein Mitspieler sich zu einem Spiel verbinden kann oder nicht. Dabei werden
beim Verbinden eines Spielers alle diese Regeln durchlaufen und nur wenn alle
davon \ib{true} zurückliefern, darf der Spieler beitreten.


\section{LobbyActivity}
Die LobbyActivity ist eine abstracte Klasse, die eine Grundfunktionalität
mitbringt, sodass man sich darum nicht mehr selbst kümmern muss.
\begin{wrapfigure}{r}{0.5\textwidth}
   \centering
   \includegraphics[width=0.48\textwidth]{chapter3/lobby}
   \caption[Von Text umflossenes Bild]{LobbyActivity}
   \label{fig:Wrap}
 \end{wrapfigure}  
Sie bietet eine UI-Oberfläche, welche es ermöglicht einen Namen für den Spieler
anzugeben, ein Spiel zu eröffnen oder sich zu einem Spiel zu verbinden. Auf dem
Bild sieht man die zwei Einträge \ib{game} und
\ib{game2} bei dem es sich um zwei gerade offene Spiele handelt. Um
sich zu denen zu verbinden muss man nur den Namen berühren und schon verbindet
sich zu dem Spiel. Da es sich jedoch um eine abstrakte Klasse handelt, muss man
nämlich die Methoden \ib{getJoinChannelView} und \ib{getHostChannelView}
implementieren.
Bei diesen Methoden handelt es sich um eine definition der Klassen, die die
Activity beschreiben, welche geöffnet werden soll, wenn eine gegebene Aktion
durchgeführt wird. Das heißt wenn ein neues Spiel erstellt wird, so muss die
Methode \ib{getHostChannelView()} die Activity Klasse definieren,
welche geöffnet werden soll, wenn ein Spiel geöffnet wird. Es spricht natürlich
auch nichts dagegen die beiden Methoden die selbe Activity übergeben zu lassen,
solange die Activity die logische Auseinandersetzung mit dem Host und Clienten
übernimmt.
Die Behandlung der Buttons \ib{create} und \ib{refresh} werden durch die
Methoden \ib{refresh(View)} und \ib{create(View)} representiert.
Die Methode \ib{create} z.B. überprüft zuerst ob der Spielername und der
Spielname angegeben sind und startet darauf die Session, wie im Codeausschnitt
~\ref{startSession} aufgeführt.
\begin{lstlisting}[caption=Session starte,label=startSession]
PTPHelper.getInstance().setHostChannelName(channelName);
PTPHelper.getInstance().setPlayerName(playerName);
PTPHelper.getInstance().hostStartChannel();
updateUIState(PTPHelper.SESSION_HOSTED);
\end{lstlisting}
Der letzte Befehl graut alle UI Elemente aus, sodass während man verbindet keine
weiteren Aktionen ausgeführt werden können. Das Verbinden zu einen Spiel
geschieht ähnlich, jedoch über einen \ib{ClickListener}, da es sich bei den
Einträgen um eine Liste handelt, welche bei der Berührung den \ib{ClickListener} entsprechend aufrufen.
Natürlich kann der Entwickler auch seine eigene Lobby implementieren, dazu muss
er nur die Klasse \ib{AbstractLobbyActivity} implementieren, welche
nur die definition der Methode \ib{connectionStateChanged(int)} aus
dem LobbyObserver besitzt und vom PTPHelper aufgerufen wird, wenn sich der
Verbindungszustand ändert.


\section{PTPService}
Die PTPService Klasse besitzt die eigentliche Funktionalität der Bibliothek und
ist dafür verantwortlich die Verbindung mit dem Bus zu erstellen und
entsprechend zu konfigurieren. Der PTPService ist eine Unterklasse von Service aus dem
Android SDK, welche im Hintergrund gestartet wird und in einem seperaten Thread
läuft. Der Service wird von der Android VM selber gestartet und es gibt keine
direkten Zugriff auf die Instanz von dieser Service Klasse, somit ist man darauf
angewiesen die Kommunikation mit einem Nachrichtensystem zu realisieren. Android
bietet hierfür ein Nachrichtensystem an um mit dem Service zu kommunizieren.
Jedoch wurde in diesem Rahmenwerk auf die Verwendung dessen, bis auf den
\ib{Handler}, weitgehend verzichtet um zum einen eine gewissen Unabhängigkeit
vom Android SDK zu bekommen, denn wie schon erwähnt ändert sich die API des Android SDKs gelegentlich. Weiterhin ist die
Verwendung des weitbekannten Observer-Patterns eine gute Wahl um eine
Flexibilität bei der Weiterentwicklung des PTPFramework zu gewährleisten.
Wenn der PTPService erstellt wird, wird seine \textit{\textbf{onCreate()}}
Methode aufgerufen in der der Service sich als Observer beim PTPHelper
registriert. Daraufhin kann der PTPService Nachrichten erhalten um Aktionen, wie
sich zu einem Spiel zu verbinden oder Eins zu erstellen, ausführen.
Damit das Bussystem von AllJoyn initialisiert wird, bevor man damit interagieren
kann, muss man den folgenden Befehl ausführen:
\begin{lstlisting}[caption=Daemon initialisieren]
org.alljoyn.bus.alljoyn.DaemonInit.PrepareDaemon(getApplicationContext());
\end{lstlisting}
Der AllJoyn Daemon ist ein Hintergrundprozess, welcher sich um die
verbindungstechnischen Abläufe kümmert. 
Daraufhin wird der HandlerThread gestartet, welcher sich um die Nachrichten von
PTPHelper kümmert. Dabei wird wie beim PTPHelper ein BackgroundHandler
initialisiert, jedoch mit einem neu erstellem Thread.
Der Codeauschnitt ~\ref{backgroundMethods}
\begin{lstlisting}[caption=Methoden des BackgroundHandlers, label=backgroundMethods] 
    public void exit() {}
	public void connect() {	}		
	public void disconnect() {}
	public void startDiscovery() {}
	public void cancelDiscovery() {}
	public void requestName() {}
	public void releaseName() {}
	public void bindSession() {}
	public void unbindSession() {}
	public void advertise() {}
	public void cancelAdvertise() {}
	public void joinSession() {}
	public void leaveSession() {}
\end{lstlisting}
Jede dieser Methoden tut im Grunde nichts Anderes als den Befehl in eine
Nachricht zu packen und an den anderen Thread zu schicken, welcher zuvor bei der
Methode \ib{startBusThread()} erstellt wurde.
Die Methoden vom BackgroundHandler werden wiederum über die Methode
\ib{doAction(int)} ausgeführt, welche durch den HelperObserver
definiert ist. Dabei wird das Argument über einen
Switchcase ausgewertet und daraufhin die entsprechende Methode ausgeführt.

In den nächsten Unterkapiteln wird auf die einzelnen Methoden eingegangen,
welche sich im PTPService befinden und vom BackgroundHandler ausgeführt werden.
\subsection{doConnect() und doDisconnect()}
Die \ib{doConnect()} Methode ist dafür verantwortlich eine
Verbindung mit dem Bus herzustellen indem es ein BusAttachement erstellt, den
SignalHandler und das BusObject registriert. Der Codeauschnitt
~\ref{newBusAttachement} zeigt wie das BusAttachement erstellt wird.
\begin{lstlisting}[caption=BusAttachement erstellen,label=newBusAttachement]
bus = new BusAttachment(package + "appName",BusAttachment.RemoteMessage.Receive);
\end{lstlisting}
Dabei wird als erster Parameter der BusAttachement Name übergeben. Der Name ist
dafür notwendig mehrere BusAttachement bestimmten Anwendungen zuzuordnet, da die
Kommunikation über den selben Daemon läuft. Dies verhindert z.B. dass die
Kommunikation von zwei unterschiedlichen Spielen, welche beide über das
PTPFramework oder direkt mit AllJoyn realisiert sind, sich in die Quere kommen.
Der zweite Parameter bestimmt ob eingehende Nachrichten empfangen und behandelt
oder einfach verworfen werden sollen.
Danach wird in der Methode der BusListener registriert, welcher dafür zuständig
ist auf geöffnete Spiele zu reagieren. Diese Nachrichten werden dann an die
Observer weiter geschickt, siehe Codeausschnitt ~\ref{busListenerImpl}
\begin{lstlisting}[caption=BusListener Nachrichten,label=busListenerImpl]
@Override
public void foundAdvertisedName(String fullName, short transport, String namePrefix) {
	if(namePrefix.equals(packageName))
		PTPHelper.getInstance().notifyFoundAdvertisedName(getSimpleName(fullName));
};
@Override
public void lostAdvertisedName(String fullName, short transport, String namePrefix) {
	if(namePrefix.equals(packageName))
		PTPHelper.getInstance().notifyLostAdvertisedName(getSimpleName(fullName));
}
@Override
public void busDisconnected() {
	PTPHelper.getInstance().notifyBusDisconnected();
}
\end{lstlisting}
\newpage
Die Methode \ib{getSimpleName(String)} tut nichts anderes, als aus
einem vollständigen Namen, welcher sich aus dem Packagenamen und dem
Channelnamen zusammensetzt, nur den Channelname zu extrahieren und an die
Observer weiterzuschicken. Da der Packagename sich innerhalb der Anwendung nicht
ändert, wird auch nur der Channelname verwendet. Daraufhin wird der BusObject
registriert, was im Codeausschnitt ~\ref{regBusObject} zu sehen ist.
\begin{lstlisting}[caption=BusObject registrieren,label=regBusObject]
Status status;
BusObject busObject = PTPHelper.getInstance().getBusObject(); 
if(busObject != null){
	status = bus.registerBusObject(busObject, objectPath+ "/" + getDeviceID());
	if (Status.OK != status) {			
		Log.e(TAG, "Cannot register : " + status);
		return;
	}
}
\end{lstlisting}
Dabei wird der BusObject genommen welcher bei der Initialisierung vom PTPHelper
übergeben wurde. Der BusObject wird später dazu benötigt einen sogenannte
SignalEmmiter zu bekommen, über welchen man Nachrichten an andere Teilnehmer
schicken kann. Der Pfad, unter welchen der BusObject abgelegt wird, muss innerhalb des
BusSystems einzigartig sein, um Konflikte zwischen den BusObjekten zu
vermeiden. Wie man an dem Beispiel sieht, ist der Pfad wie bei einen normalen
Dateisystem organisiert und wird über das Slashzeichen getrennt. Um die
Einzigartigkeit jedes Bus Objektes zu ermöglichen wurde als Teilpfad die Geräte
ID benutzt. Wie man an die Geräte ID kommt, zeigt der Codeausschnitt
~\ref{deviceID}.
\begin{lstlisting}[caption=Geräte ID,label=deviceID]
private String getDeviceID(){
	TelephonyManager telephonyManager = (TelephonyManager) getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
	return telephonyManager.getDeviceId();
}
\end{lstlisting}
Jedoch muss man dazu noch in dem AndroidManifest die notwendige Erlaubniss
\ib{READ\_PHONE\_STATE} hinzufügen.
Darufhin wird die \ib{bus.connect()} Methode aufgerufen um mit dem
Bus zu verbinden. Wenn die Verbindung erfolgreich war, was man über den
Status als Rückgabewert erfährt, wird der SignalHandler registriert, welcher
zuvor bei der Initialisierung des PTPHelper übergeben wurde.
Schließlich wird die UniqueID des BusAttachements an den PTPHelper übergeben,
welcher einen busweiten einzigartigen String darstellt, sowie auch der Zustand
der Verbindung auf \ib{CONNECTED} gesetzt, siehe Codeausschnitt ~\ref{setState}
\begin{lstlisting}[caption=UniqueID und Verbindungstatus setzen,label=setState]
PTPHelper.getInstance().setUniqueID(bus.getUniqueName());
PTPHelper.getInstance().setConnectionState(PTPHelper.CONNECTED);
\end{lstlisting}
Die \ib{doDisconnect()} Methode ist im Prinzip dafür verantworlich
alle Handler und das BusObject abzumelden und die Verbindung zu trennen.

\subsection{doStartDiscovery() und doStopDiscovery()}
Die Methode \ib{doStartDiscovery()} wird meist zu begin, nach dem
die Verbindung aufgebaut ist, ausgeführt. Die ist dafür verantworlich dem
BusAttachement mitzuteilen auf offene Spiele zu horchen und die dem Observer
mitzuteilen. Dies geschieht über den einfachen Methodenaufruf
\ib{bus.findAdvertisedName(packageName)}.
Wobei der \ib{packageName} das Prefix für den Name darstellt. Somit
würde das BusAttachement auf alle offene Spiele reagieren, welche den Prefix mit
dem \ib{packageName} haben. Um dann das Entdecken von offenen
Spielen auch zu beenden kann wird die Methode
\ib{doStopDiscovery()} ausgeführt, welche dann die Methode
\ib{bus.cancelFindAdvertisedName(packageName)} ausführt.

\subsection{doBindSession() und doUnbindSession()}
Die \ib{doBindSession()} Methode wird dafür benötigt um eine neue Session zu
erstellen, wenn man ein neues Spiel erstellt. Dabei werden unterschiedliche
Konfigurationen vorgenommen. Zum einen muss man den SessionPort festlegen und
die Transportparameter konfigurieren. Bei den Transportparametern handelt es
sich darum, ob man die Verbindung über Bluetooth, WifiDirect oder Lan zulässt,
ob es sich hierbei um eine Multipoint Session handelt, ob die Session Beitreter
von außerhalb des lokalen Gerätes befinden dürfen und ob die Daten roh oder als
Nachrichten verpackt verschickt werden.
In diesem Fall wird nur die Verbindung über Wlan zugelassen, es soll sich um
eine Multipointverbindung handeln, die Daten sollen als Nachrichten
verschickt werden und es dürfen alle sich zu der Session verbinden, also auch
von anderen Geräten aus. Wie die Konfiguration vorgenommen wird sieht man im
Codeausschnitt ~\ref{portConfig}
\begin{lstlisting}[caption=Sessionkonfiguration,label=portConfig]
Mutable.ShortValue mutableContactPort = new Mutable.ShortValue(contactPort);
SessionOpts sessionOpts = new SessionOpts(SessionOpts.TRAFFIC_MESSAGES,
				true, SessionOpts.PROXIMITY_ANY, SessionOpts.TRANSPORT_WLAN);		
\end{lstlisting}
Als \ib{contactPort} wird der Standartwert 100 genommen.
Neben den Konfigurationsparametern benötigt man auch einen
\ib{SessionPortListener}, welcher sich um die Verbindungsanfragen von anderen
Geräten kümmert, sowie bei einer erfolgreichen Verbindung die nötigen Schritte
einleitet. Der \ib{SessionPortListener} implementiert eine Methode, die im
Codeausschnitt ~\ref{acceptJoiner}:
\begin{lstlisting}[caption=SessionPortListener implementierung,label=acceptJoiner] 
public boolean acceptSessionJoiner(short
sessionPort, String joiner, SessionOpts sessionOpts) {
		if(sessionPort == contactPort){					
			return PTPHelper.getInstance().canJoin(joiner);
		}
		return false;
}
\end{lstlisting}
Dabei wird zuerst geprüft ob der SessionPort übereinstimmt und danach werden die
möglicherweise definierten \ib{SessionJoinRules} durchlaufen. Erst wenn alle die
Regeln \ib{true} zurückliefern wird das Beitreten zur Session gewährt. 

\begin{lstlisting}[caption=Als Host den SignalEmitter bekommen,label=hostSignalEmitter] 
public void sessionJoined(short sessionPort,int sessionId,String joiner){
if(firstJoiner){
	firstJoiner = false;
	hostSessionId = sessionId;
	SignalEmitter emitter = new SignalEmitter(PTPHelper.getInstance().getBusObject(), sessionId, SignalEmitter.GlobalBroadcast.Off);
	hostInterface = emitter.getInterface(PTPHelper.getInstance().getBusObjectInterfaceType());
	PTPHelper.getInstance().setSignalEmiter(hostInterface);
	PTPHelper.getInstance().notifyMemberJoined(joiner);
	bus.setSessionListener(sessionId, new PTPSessionListener());
	}
}
\end{lstlisting}
Die zweite Methode umfasst ein etwas kompliziertes Szenario.
AllJoyn erlaubt es nicht einen Host, welcher eine Session bindet, sich zu dieser auch zu verbinden.
\newpage
Um jedoch als Host auch am Spiel teilnehmen zu können wird dieses Verhalten
durch einen Umweg erreicht.
Durch die Methode aus dem Codeausschnitt ~\ref{hostSignalEmitter} erfährt man
die bis dahin unbekannte \ib{SessionID}, da sie durch das Binden der Session nicht mitgeteilt wird. Daraufhin kann man mit
der \ib{SessionID} einen \ib{SignalEmitter} erstellen, der als Endpunkt fungiert
und das Verschicken von Nachrichten ermöglicht. Zusätzlich lässt sich der
\ib{PTPSessionPortListener} an die Session binden. Somit ist es
 dem Host nur möglich zu funktionieren, wenn sich der erste
Teilnehmer verbunden hat.Zum schluss wird
der \ib{SessionPortListener} beim Bus registriert und eine Session erstellt,
siehe Codeausschnitt ~\ref{bindSessionPort}.
\begin{lstlisting}[caption=Session erstellen,label=bindSessionPort]
bus.bindSessionPort(mutableContactPort, sessionOpts, sessionPortListener);
\end{lstlisting}

In der Methode \ib{doUnbindSession()} wird durch den einfachen Methodenaufruf
\ib{bus.unbindSessionPort(contactPort)}, die Session, welche an den
\ib{contactPort} gebunden ist, geschlossen:

\subsection{doRequestName() und doReleaseName()}
Die Methoden \ib{doRequestName()} und \ib{doReleaseName()} sind dazu da um die
Spielnamen, welche man dann später durch das \ib{Advertising} an andere
Teilnehmer mitteilen kann, vom Bus zugewiesen zu bekommen. Man kann nämlich nur
Namen mitteilen, welche man auch zugewiesen bekommen hat, denn es kann ja
vorkommen, dass ein Name schon vergeben ist. Der Codeausschnitt
~\ref{requestName} zeigt die genaue Implementierung.
\begin{lstlisting}[caption=Name für Session anfordern,label=requestName]
bus.requestName(packageName + "." +PTPHelper.getInstance().getHostChannelName(),
				BusAttachment.ALLJOYN_REQUESTNAME_FLAG_DO_NOT_QUEUE);
\end{lstlisting}
Somit wird als Prefix der \ib{packgeName} verwendet und der \ib{HostChannelName}
ist der Name, welche in der Lobby hinterlegt und beim PTPHelper abgespeichert
wurde. Der zweite Parameter besagt, dass bei vorhanden Namen nichts unternommen
werden soll. Eine andere Möglichkeit bestehe nämlich den vorhandenen Namen
einfach zu ersetzen.
Durch \ib{doReleaseName()} wird der Name dann wieder freigegeben, sodass er
wieder von Anderen verwendet werden kann.
\subsection{doAdvertise() und doCancelAdvertise()}
Das sogenannte \ib{Advertising} wird dazu benutzt um anderen Teilnehmern den
Spielnamen mitzuteilen. Somit wird über einen einfachen Befehl die Mitteilung
gestartet und beendet. Zur Verdeutlichung siehe Codeausschnitt
~\ref{advertising}.
\begin{lstlisting}[caption=Session Name mitteilen,label=advertising]
String wellknownName =packageName+"."+PTPHelper.getInstance().getHostChannelName();  
bus.advertiseName(wellknownName, SessionOpts.TRANSPORT_WLAN);
...
String wellknownName = packageName+"."+PTPHelper.getInstance().getHostChannelName(); 
bus.cancelAdvertiseName(wellknownName,SessionOpts.TRANSPORT_ANY);
\end{lstlisting}
Dabei werden zum einen der Name des Spiels übergeben, als auch das
Transportmedium, in diesem fall Wlan.
\subsection{doJoinSession() und doLeaveSession()}
Die Methode \ib{doJoinSession()} ist sogesehen das entsprechende Gegenbeispiel
zu der \ib{doBindSession()} Methode. Diese Methode wird von den beitretenden
Teilnehmer ausgeführt. 
Im Codeausschnitt ~\ref{joinSession} sieht man die genauere Vorgehensweise beim
Bestreten einer Session.
\begin{lstlisting}[caption=Session beitreten,label=joinSession]
String wellKnownName = packageName + "." + PTPHelper.getInstance().getChannelName();
SessionOpts sessionOpts = new SessionOpts(SessionOpts.TRAFFIC_MESSAGES,
		true, SessionOpts.PROXIMITY_ANY, SessionOpts.TRANSPORT_WLAN);
		
Mutable.IntegerValue sessionId = new Mutable.IntegerValue();

bus.joinSession(wellKnownName, contactPort, sessionId,sessionOpts, sessionListener);
\end{lstlisting}
Hierbei werden über die /ib{SessionOpts} wie bei der \ib{doBindSession()}
Methode die ganzen Parameter für die Session festgelegt. Bei der \ib{sessionId}
handelt es sich um einen veränderbaren integer Wert, welcher bei der Ausführung
der Methode zugewiesen wird. Schließlich wird noch ein \ib{SessionListener} als
Parameter übergeben. Auch dieser Listener leitet die Nachrichten an die
Observer, welche im PTPHelper abgespeichert sind, weiter. 
Jedoch wird die Information über die SessionId dem PTPHelper nicht
mitgeteilt, da sie für den Entwickler, welcher den Observer gegebenenfalls implementiert, nicht von
Interesse sein sollte.
Falls die Verbindung erfolgreich war wird anschließend ein \ib{SignalEmitter}
erstellt und dieser an den PTPHelper übergeben, wie im Codeausschnitt
~\ref{clientSignalEmitter} aufgeführt.
\begin{lstlisting}[caption=SignalEmitter bekommen als Client,label=clientSignalEmitter] 
SignalEmitter emitter = new SignalEmitter(PTPHelper.getInstance().getBusObject(), clientSessionId, SignalEmitter.GlobalBroadcast.Off); Object clientInterface = emitter.getInterface(PTPHelper.getInstance().getBusObjectInterfaceType()); PTPHelper.getInstance().setSignalEmitter(clientInterface);
PTPHelper.getInstance().setConnectionState(PTPHelper.SESSION_JOINED);
\end{lstlisting}
\subsection{doQuit()}
Schließlich gibt es noch die \ib{doQuit()} Methode, die aufgerufen wird,
den der Service beendet werden soll. Der Codeausschnitt ~\ref{quit} zeigt den
Inhalt dieser Methode.
\begin{lstlisting}[caption=doQuit Methode,label=quit]
backgroundHandler.disconnect();
backgroundHandler.getLooper().quit();
PTPHelper.getInstance().removeObserver(this);
this.stopSelf();
\end{lstlisting}
Es wird somit die Verbindung mit dem Bus geschlossen, falls sie noch offen ist.
Dann wird der \ib{BusThread} beendet, welcher an den \ib{BackgroundHandler}
gekoppelt war. Und zum Schluss wird der Service als Observer vom PTPHelper
entfernt und beendet.
