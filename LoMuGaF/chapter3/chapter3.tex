\chapter{Implementierung}
\section{Realisierung}  
Die PTPLibrary bietet eine
einfache Schnittstelle, über die eine Kommunikation mit allen Teilnehmern ermöglicht wird. Es ist
außerdem eine Activity implimentiert worden, welche das Erstellen und das
Verbinden zu Spielen übernimmt. Diese Activity besitzt eine graphische
Oberfläche und kann bei der Implementierung eines Spiels verwendet werden. Diese
Activity wird als \ib{Lobby} bezeichnet. Die Netzwerkverbindung von AllJoyn
läuft in einem seperaten Thread und ist daher mithilfe von \ib{Handlern} von dem \ib{UI-Thread} getrennt behandelt worden,
sodass sich die beiden Threads nicht behindern. Für die
Entwicklung der PTPLibrary und der Beispielanwendungen sind 2 Android
Smartphones verwendet worden. Das erste Gerät ist ein \ib{Samsung Galexy S3 GT-I9300} mit dem Betriebssystem Android 4.1.2.
Das zweite Gerät ist ein \ib{Sony Xperia Tipo ST21i}, das das Betriebssystem
Android 4.0.2 besitzt. Die Verbindung ist mithilfe eines \ib{WiFi AccessPoint} von
Android erstellt worden, zu dem sich das andere Gerät verbunden hat.
Um die Bibliothek benutzen zu können muss der
Entwickler nur die PTPLibrary als Bibliothek in sein Projekt einbinden. 


\section{PTPHelper}
Der PTPHelper ist eine Schnittstelle zwischen dem Spiel und
dem Hintergrundservice, der sich um die Verbindung kümmert.
Nach Abwägen mehrerer Möglichkeiten wie der Service, der sich um die
Verbindungstechnischen Abläufe kümmert, in die Applikation integriert werden
kann, ist die Wahl schließlich auf die Benutzung eines Singletons gefallen.
Alternativ ließe sich eine abstrakte Application benutzen, die der Entwickler in
seinem Projekt implementieren müsste, aber dies würde dem Entwickler auch eine
Architekturentscheidung aufzwingen. Der Entwickler kann entscheiden, wann der
Service gestartet wird und wie damit interagiert werden soll. So kann z.B.
der Einzelspielermodus vollkommen ohne der Benutzung des PTPHelpers realisiert
werden und erst beim Multiplayermodus wird der Service gestartet. Um den
PTPHelper zu initialisieren muss der Entwickler in seinem Code den folgenden Befehl aus dem
Codeausschnitt ~\ref{initHelper} ausführen.

\begin{lstlisting}[caption=Helper initialisieren,label=initHelper]
PTPHelper.initHelper("appName", context,MyLobby.class);
\end{lstlisting}

Der Parameter \ib{appName} ist der Name der Application und legt den Namen für
das \ib{BusAttachement} fest. Beim \ib{context} handelt es sich um die Android
Context Klasse, für das Starten des Services. Der \ib{MyLobby.class}
Parameter gibt an, welche Activity als Lobby gestartet werden soll. Daraufhin
kann über den Getter die initialisierte Instanz gefragt werden, wie im Codeausschnitt ~\ref{getInstance} gezeigt.
\begin{lstlisting}[caption=Getter für die initialisierte Instanz,label=getInstance] 
PTPHelper.getInstance();
\end{lstlisting}
Es muss jedoch beachten werden, das das Starten des Hintergrundservices ein
asynchroner Prozess ist, und der Hintergrundservice nach der Initialisierung
nicht vollständig gestartet gestartet ist.
Um den Zustand des Hintergrundservices zu erfahren kann über den Methodenaufruf,
wie im Codeausschnitt ~\ref{connectionState} gezeigt,dieser erfragt werden.
\begin{lstlisting}[caption=Verbindungstatus erfragen,label=connectionState]
PTPHelper.getIntance().getConnectionState();
\end{lstlisting}
Dabei handelt es sich um einen Integer, der die Werte CONNECTED=7
und DISCONNECTED=8 annehmen kann.
Damit der Service nur so lange läuft wie die Application wird der Service
an diese gebunden, siehe Codeausschnitt ~\ref{bindService}.\newpage

\begin{lstlisting}[caption=Service binden,label=bindService]
Intent service = new Intent(context, PTPService.class);
boolean bound = context.bindService(service,new PTPServiceConnection(),Service.BIND_AUTO_CREATE);
\end{lstlisting}
Bei dem \ib{PTPServiceConnection} Objekt handelt es sich um einen
Listener, der benachrichtigt wird, wenn die Verbindung zum Service aufgebaut
oder getrennt ist. Der Flag \ib{Service.BIND\_AUTO\_CREATE}
besagt, dass nach dem Binden des Services der Service automatisch über die
Methode \ib{onCreate()} erstellt werden soll.

Die PTPLibrary ist dazu ausgelegt nur im \ib{WLAN}\cite{wlan} zu funkionieren,
somit wird bei der Initialisierung des PTPHelpers geprüft, ob das Smartphone über eine WLAN
Verbindung verfügt.
Dies wird über den \ib{WiFiManager} realisiert, wie im Codeausschnitt
~\ref{wifiManager} dargestellt.
\begin{lstlisting}[caption=WifiManager,label=wifiManager]
WifiManager wifiManager =(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
WifiInfo currentWifi = wifiManager.getConnectionInfo(); 
if((currentWifi==null || currentWifi.getSSID()== null || currentWifi.getSSID().isEmpty()){
	//Zeige, dass es keine WiFi Verbindung gibt
}
\end{lstlisting}
Im Falle dessen, dass das Smartphone über keine WLAN-Verbindung verfügt, wird
die Initialisierung abgebrochen und der Service wird nicht gestartet.
Android ermöglicht es zusätzlich ein \ib{AccessPoint}\ib{accessPoint} zu
erstellen, zu den sich andere Smartphones verbinden können. Die Information über den Zustand des
AccesPoints ist jedoch keine öffentliche Methode des WiFi-Manangers, sodass
diese Information nur über Java-Reflection erfragt werden kann. Wie das
funktioniert wird im Codebeispiel ~\ref{reflect} verdeutlicht.

\begin{lstlisting}[caption=Access Point Status erfragen,label=reflect]
Method method = wifiManager.getClass().getMethod("isWifiApEnabled");
state = (Boolean) method.invoke(wifiManager);
\end{lstlisting}
Nachdem der PTPHelper initialisiert ist und der Service gestartet wurde, kann
über den PTPHelper den Service mitgeteilt werden z.B. sich zu einer Session zu
verbinden oder eine Session zu erstellen.
Dies geschieht über Methodenaufrufe, wie im Beispiel ~\ref{clientHost}
gezeigt.

\begin{lstlisting}[caption=Host/Client Session,label=clientHost]
//Host
PTPHelper.getInstance().setHostSessionName("sessionName")
PTPHelper.getInstance().hostStartSession()
...
//Client
PTPHelper.getInstance().setClientSessionName("sessionName");
PTPHelper.getInstance().joinSession();
\end{lstlisting}

Der PTPHelper erlaubt es zusätzlich verschiedene Observer zu registrieren, um
auf möglichliche Events entsprechend reagieren zu können.
Zu den Observern gehören die Interfaces LobbyObserver, BusObserver,
SessionObserver und der HelperObserver, die der Entwickler selber implementieren
kann.
Zu den LobbyObservern gehört z.B. auch die AbstractLobbyActivity und
implementiert die Methode \ib{conncetionStateChanged(int state)},
die aufgerufen wird, wenn der sich der Verbindungstatus ändert.
Der BusObserver hört auf den Bus selbst und definiert die folgenden Methoden:
\begin{lstlisting}[caption=BusObserver]
public void foundAdvertisedName(String sessionName);
public void lostAdvertisedName(String sessionName);
public void busDisconnected();
\end{lstlisting}
Durch die Implementierung des BusObservers kann auf das
Öffnen und Schließen der Spiele reagiert werden, falls die in der PTPLibrary
vorimplementierte Behandlung, für den Entwickler nicht ausreichend ist. Die \ib{foundAdvertisedName} Methode wird
aufgerufen, wenn eine neue Session gefunden wurde und \ib{lostAdvertisedName}
wenn eine bekannte Session geschlossen wurde oder nicht mehr erreichbar ist.
Die \ib{busDisconnected} Methode wird aufgerufen, wenn das BusAttachement
keine Verbindung zum Bus mehr hat. Der BusObserver ist z.B.
im PTPHelper schon einmal implementiert und er sorgt dafür, dass neu erstellte Spiele in einer Liste
\ib{foundSessions} gespeichert und entsprechend auch
entfernt werden. Dies ist notwendig um in der Lobby alle gerade offenen Spiele
anzeigen zu können.
\newline
Der \ib{SessionObserver} definiert Methoden um auf Events zu reagieren,
die im Bezug zu einer Session stehen.
Dies ermöglicht es dem Entwickler bestimmte Aktionen auszuführen, falls neue
Spieler sich zur einer Session verbinden, sich von der
Session trennen oder die Verbindung zur Session abbricht. 
Schließlich gibt es noch den \ib{ServiceHelperObserver}, der z.B.vom PTPService
implementiert wird. Dieser Observer hört auf den Helper, der über die Methode \ib{doAction(int action)} verschieden Aktionen
mitteilt. So hat z.B. der Methodenaufruf
aus Codeausschnitt ~\ref{joinSession}
\begin{lstlisting}[caption=verbinde zur Session,label=joinSession]
PTPHelper.getInstance().joinSession();
\end{lstlisting}
zur Folge, dass der PTPHelper den Service über den Observer mitteilt sich zu
einer Session zu verbinden. 
Die oben genannten Observer sind Mithilfe eines \ib{Handlers} vom
Hintergrundthread abgekoppelt. Der Entwickler muss dadurch bei der
Implementierung der Observer sich keine Gedanken um Threadkollisionen machen.
Der PTPHelper besitzt einen \ib{BackgroundHandler}, der im
Konstruktor erstellt und an den UI-Thread gekoppelt wird, siehe Codeausschnitt 
~\ref{uiBackgroundThread}.
\begin{lstlisting}[caption=UI-Thread BackgroundHandler,label=uiBackgroundThread]
backgroundHandler = new BackgroundHandler(Looper.getMainLooper());
\end{lstlisting}
Sobald der Hintergrundprozess aus dem PTPService die Observer benachrichtigen
will und z.B. die Methode \ib{notifyMemberJoined(String)} ausführt, wird diese
Nachricht an den \ib{BackgroundHandler} geleitet.
Der \ib{BackgroundHandler} reagiert über die Methode
\ib{handleMessage(Message)} auf die Nachricht, indem jedoch die Methode auf dem
UI-Thread ausgeführt wird.
Das \ib{SessionJoinRule} Interface definiert die Methode \ib{canJoin(String joinersUniqueId)}.
Darüber kann der Entwickler bestimmte Regeln festlegen, die darüber entscheiden,
ob ein Mitspieler sich zu einem Spiel verbinden kann oder nicht. Dabei werden
beim Verbinden eines Spielers alle diese Regeln durchlaufen und nur wenn alle
davon \ib{true} zurückliefern, darf der Spieler beitreten.\newline
Schließlich gibt es noch den \ib{DataListener} Interface, das für das Empfangen
von Daten notwendig ist und die Methode
\ib{dataSentToAllPeers(String,int,String[])} definiert. Der erste String
Parameter in der Methode ist die \ib{Unique ID} des Versenders. Die beiden
anderen Parameter können beliebige Daten beinhalten. Diese Methode wird jedesmal
aufgerufen, wenn eine Nachricht an alle Smartphones geschickt wird. Die Implementierung und die Registierung des Listeners ist notwendig für das Empfangen von Daten. Die Abbildung \ref{fig:messSeq} veranschaulicht den Nachrichtenablauf beim Versenden von Daten.
Die Methode \ib{sendDataToAllPeers(int arg,String[] data)}, die beim PTPHelper implementiert ist, erlaubt es Daten an alle zu der Session
verbundenen Spielern zu verschicken. Diese Methode sendet die Daten über
den \ib{SignalEmitter} an die anderen Spieler. Die \ib{SignalHandler}
reagieren auf diese Nachricht und leiten sie an die \ib{DataListener},
die vom Entwickler beim \ib{PTPHelper} registiert wurden. 
\newpage
AllJoyn baut auf einem \ib{DBus System} auf und unterliegt somit dessen
Specificationen\cite{dbus}. Es ist daher zu beachten, dass der String, der verschickt wird, nur eine \ib{UTF-8} Formatierung besitzen darf.
\begin{figure}
   \centering
   \includegraphics[width=1\textwidth]{chapter3/sequence}
   \caption[messSeq]{Nachrichtenablauf}
   \label{fig:messSeq}
\end{figure} 
Der SignalHandler wird beim PTPHelper erstellt, und er definiert eine Methode.
\begin{lstlisting}[caption=SignalHandler Methode,label=signalMethod]
@BusSignalHandler(iface = "de.ptpservice.PTPBusObjectInterface", signal = "SendDataToAllPeers")
public void SendDataToAllPeers(String sentFrom,int arg, byte[] data) {
	notifyDataListenersAllPeers(sentFrom,arg,data);
}
\end{lstlisting}
Der Codeausschnitt \ref{signalMethod} zeigt die Methode, die für
die Kommunikation zwischen den Smartphones benutzt wird. Die Implementierung der
Methode im SignalHandler, bedeutet dass diese Methode aufgerufen wird, wenn eine
Nachricht an jedes Smartphone geschickt wird. In Zeile 3, werden die empfangenen
Daten an die \ib{DataListener} geschickt.

\newpage


\section{LobbyActivity}
Die LobbyActivity ist eine abstracte Klasse, die eine Grundfunktionalität
mitbringt. Die Lobby, die die LobbyActivity implementiert, zeigt die Abbildung
~\ref{fig:lobby}.
\begin{wrapfigure}{r}{0.5\textwidth}
   \centering
   \includegraphics[width=0.48\textwidth]{chapter3/lobby}
   \caption[Von Text umflossenes Bild]{LobbyActivity}
   \label{fig:lobby}
 \end{wrapfigure}  
Sie bietet eine UI-Oberfläche, die es ermöglicht einen Namen für den Spieler
anzugeben, ein Spiel zu eröffnen oder sich zu einem Spiel zu verbinden. Auf dem
Bild sieht man die zwei Einträge \ib{game} und
\ib{game2} bei dem es sich um zwei offene Spiele handelt. Für die Verbindung
zu den Spiele, muss nur der entsprechende Name berührt werden. Die
LobbyActivity ist eine abstrakte Klasse, daher müssen die Methoden
\ib{getJoinSessionView} und \ib{getHostSessionView} imlementiert werden.
Bei diesen Methoden handelt es sich um eine Definition der Klassen, die die
Activities beschreiben, die geöffnet werden soll, wenn eine gegebene Aktion
durchgeführt wird. Das heißt wenn ein neues Spiel erstellt wird, so muss die
Methode \ib{getHostSessionView()} die Activity Klasse definieren,
die geöffnet werden soll, wenn ein Spiel geöffnet wird.Die beiden Methoden
können auch die selbe Activity übergeben, wenn die Activity die
logische Auseinandersetzung mit dem Host und Clienten übernimmt.

\section{PTPService}
Die PTPService Klasse besitzt die eigentliche Funktionalität der Bibliothek und
ist dafür verantwortlich die Verbindung mit dem Bus zu erstellen und diese
entsprechend zu konfigurieren. Der PTPService ist eine Unterklasse von Service aus dem
Android SDK, die im Hintergrund gestartet wird und in einem seperaten Thread
läuft. Der Service bietet keine direkten Zugriff auf die Instanz, und somit muss
die Kommunikation mit einem Nachrichtensystem realisiert werden. Android bietet
hierfür ein Nachrichtensystem an, um mit dem Service zu kommunizieren.
Die Verwendung des Nachrichtensystems von Android beschränkt sich jedoch auf
die Verwendung des \ib{Handlers}.
Wenn der PTPService erstellt wird, wird seine \textit{\textbf{onCreate()}}
Methode aufgerufen, in der der Service sich als Observer beim PTPHelper
registriert. Daraufhin kann der PTPService Nachrichten erhalten um Aktionen
auszuführen.
Damit das Bussystem von AllJoyn benutzt werden kann, muss dieser initialisiert
werden. Das geschieht über einen Befehlsaufruf, der im Codeausschnitt
\ref{initDaemon} dargestellt ist. 
\begin{lstlisting}[caption=Daemon initialisieren,label=initDaemon] 
org.alljoyn.bus.alljoyn.DaemonInit.PrepareDaemon(getApplicationContext());
\end{lstlisting}
Der AllJoyn Daemon ist ein Hintergrundprozess, der sich um die
verbindungstechnischen Abläufe kümmert. 
Daraufhin wird der HandlerThread gestartet, der sich um die Nachrichten von
PTPHelper kümmert. Dabei wird wie beim PTPHelper ein BackgroundHandler
initialisiert. Der BackgroundHandler wird jedoch an einen neu erstellten Thread
gekoppelt. Der PTPHelper teilt über die Observer dem PTPService mit, welche
Aktionen ausgeführt werden müssen.

\subsection{doConnect() und doDisconnect()}
Die \ib{doConnect()} Methode ist dafür verantwortlich eine
Verbindung mit dem Bus herzustellen indem es ein BusAttachement erstellt, den
SignalHandler und das BusObject registriert. Der Codeauschnitt
~\ref{newBusAttachement} zeigt wie das BusAttachement erstellt wird.
\begin{lstlisting}[caption=BusAttachement erstellen,label=newBusAttachement]
bus = new BusAttachment(package + "appName",BusAttachment.RemoteMessage.Receive);
\end{lstlisting}
Dabei wird als erster Parameter der BusAttachement Name übergeben. 
Es ist möglicht mit AllJoyn mehrere Anwendungen auf den selben Smartphone laufen
zu lassen. Um jedoch die einzelnen BusAttachements den Applicaiton zuweisen zu
können, werden sie mit einem Namen versehen.
Der zweite Parameter bestimmt, ob eingehende Nachrichten empfangen und behandelt
oder verworfen werden sollen.
Danach wird in der Methode der BusListener registriert, der dafür zuständig
ist auf geöffnete Spiele zu reagieren. Diese Nachrichten werden dann an die
Observer weiter geleitet, die beim PTPHelper registriert sind.
Daraufhin wird der BusObject registriert, das im Codeausschnitt
~\ref{regBusObject} zu sehen ist.
\begin{lstlisting}[caption=BusObject registrieren,label=regBusObject]
BusObject busObject = PTPHelper.getInstance().getBusObject(); 
status = bus.registerBusObject(busObject, objectPath+ "/" + getDeviceID());
\end{lstlisting}
Dabei wird ein BusObject genommen, der bei der Initialisierung vom PTPHelper
erstellt wurde. Der BusObject wird später dazu benötigt einen sogenannte
SignalEmmiter zu bekommen, über den Nachrichten an alle Smartphones geschickt
werden kann.
Der Pfad, unter den der BusObject abgelegt wird, muss innerhalb des BusSystems
einzigartig sein, um Konflikte zwischen den BusObjekten zu vermeiden. Der Pfad
 ist wie bei einen Dateisystem organisiert und wird durch das
 Slashzeichen getrennt. Um die Einzigartigkeit eines Pfaded für jedes Bus
 Objektes zu ermöglichen, wurde als Teilpfad die \ib{Geräte ID} benutzt. 
 Der Codeausschnitt ~\ref{deviceID} zeigt, wie die Geräte ID erfragt werden
 kann.
\begin{lstlisting}[caption=Geräte ID,label=deviceID]
	TelephonyManager telephonyManager = (TelephonyManager) getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
	telephonyManager.getDeviceId();
\end{lstlisting}
Im AndroidManifest muss die notwendige Erlaubniss
\ib{READ\_PHONE\_STATE} hinzugefügt werden, um die Geräte ID zu bekommen.
Darufhin wird die \ib{bus.connect()} Methode aufgerufen, um mit dem
Bus zu verbinden. Wenn die Verbindung erfolgreich war, wird der SignalHandler registriert.
Schließlich wird die UniqueID des
BusAttachements an den PTPHelper übergeben, die einen busweiten einzigartigen
String darstellt.
Die \ib{doDisconnect()} Methode meldet alle Handler und das BusObject ab
und trennt die Verbindung.

\subsection{doStartDiscovery() und doStopDiscovery()}
Die Methode \ib{doStartDiscovery()} wird am Anfang, nach dem
die Verbindung aufgebaut ist, ausgeführt. Die Methode ist dafür verantworlich
dem BusAttachement mitzuteilen nach offene Spielen zu suchen und diese dem
Observer mitzuteilen. Dies geschieht über den Methodenaufruf
\ib{bus.findAdvertisedName(packageName)}.
Der \ib{packageName} stellt den Prefix für den Session Namen dar. Das
BusAttachement reagiert auf alle offene Spiele, die den Prefix mit
dem \ib{packageName} haben. Wenn das Suchen nach offenen Spielen beendet werden
soll, kann die Methode \ib{doStopDiscovery()} ausgeführt werden.

\subsection{doBindSession() und doUnbindSession()}
Die \ib{doBindSession()} Methode ist für das Erstellen einer neuen Session
zuständig. Dabei werden unterschiedliche
Konfigurationen vorgenommen, die zur Erstellung einer Session notwendig sind.
Zum einen muss der \ib{SessionPort} festgelegt und die Transportparameter
konfiguriert werden. Bei den Transportparametern wurde festgelegt, dass die
Kommunikation über das WLAN realisiert wird, dass sich alle anderen Smartphones
zu der Session verbinden können, und dass die Daten als Nachrichten verschickt
werden. Außerdem wird festgelegt, dass sich bei der Session um eine
\ib{Multipoint-Verbindung}\cite{multipoint} handelt. Als \ib{SessionPort} wird
der Standartwert 100 genommen. Dieser kann jedoch beim PTPHelper über die
Methode \ib{setContactPort} verändert werden. Neben den Konfigurationsparametern
wird auch ein \ib{SessionPortListener} benötigt, der sich um die
Verbindungsanfragen von anderen Smartphones kümmert, sowie bei einer
erfolgreichen Verbindung die nötigen Schritte einleitet. Der \ib{SessionPortListener}
durchläuft alle \ib{SessionJoinRules}, die beim PTPHelper registiert sind. Erst
wenn alle diese Regeln \ib{true} zurückliefern wird das Beitreten zur Session
gewährt.

\begin{lstlisting}[caption=Als Host den SignalEmitter bekommen,label=hostSignalEmitter] 
public void sessionJoined(short sessionPort,int sessionId,String joiner){
if(firstJoiner){
	firstJoiner = false;
	hostSessionId = sessionId;
	SignalEmitter emitter = new SignalEmitter(PTPHelper.getInstance().getBusObject(), sessionId, SignalEmitter.GlobalBroadcast.Off);
	hostInterface = emitter.getInterface(PTPHelper.getInstance().getBusObjectInterfaceType());
	PTPHelper.getInstance().setSignalEmiter(hostInterface);	
	bus.setSessionListener(sessionId, new PTPSessionListener());
	}
}
\end{lstlisting}
Die zweite Methode \ib{sessionJoined} des \ib{SessionPortListeners} behandelt
ein etwas komplizierteres Szenario.
AllJoyn erlaubt es nicht einen Host, der eine Session bindet, sich zu dieser
auch zu verbinden.
Um jedoch als Host auch am Spiel teilnehmen zu können wird dieses Verhalten
durch einen Umweg erreicht.
Durch die Methode aus dem Codeausschnitt ~\ref{hostSignalEmitter} wird die bis
dahin unbekannte \ib{SessionID} übergeben.
Mit der \ib{SessionID} wird ein \ib{SignalEmitter} erstellt, der als
\ib{Endpunkt} fungiert und das Verschicken von Nachrichten ermöglicht. Somit ist
es dem Host nur möglich zu funktionieren, wenn sich der erste Spieler verbunden
ist. Außerdem wird in Zeile 8 ein \ib{PTPSessionListener} registriert, der auf
das Betreten sowie das Verlassen der Session hört und diese Informationen an den
PTPHelper weiterleitet.
Zum Schluss wird mit dem \ib{SessionPortListener} und dem \ib{SessionPort}, über
die Methode \ib{bus.bindSessionPort()}, die Session erstellt.
In der Methode \ib{doUnbindSession()} wird durch den einfachen Methodenaufruf
\ib{bus.unbindSessionPort(contactPort)}, die Session, die an den \ib{contactPort} gebunden ist, geschlossen. Es ist noch anzumerken, dass der
\ib{contactPort} nicht mit dem Netzwerkport zu verwechseln ist, der in \ib{TCP}
oder \ib{UDP} Verwendung findet. Der \ib{contactPort} ist nur eine AllJoyn
weite Nummer, die für das Erstellen von Sessions benötigt wird.

\subsection{doRequestName() und doReleaseName()}
Die Methoden \ib{doRequestName()} und \ib{doReleaseName()} sind dazu vorgesehen,
um die Sessionnamen, die später durch das \ib{Advertising} an andere
Spieler mitgeteilt werden können, vom Bus zugewiesen zu bekommen. Es dürfen
Sessionnamen nur dann an Andere mitgeteilt werden, wenn diese vom Bus auch
zugewiesen worden sind. Der Sessionname wird über die Methode
\ib{bus.requestName()} angefordert. Dem Sessionnamen wird auch der
\ib{Packgename} der Applikation vorgesetzt, sodass sich der angeforderte Name
aus dem \ib{Packagenamen} und und dem \ib{Sessionnamen} zusammensetzt.Es wird außerdem überprüft, ob der Sessioname schon vorhanden ist, sodass in diesem Fall das Erstellen einer Session abgebrochen wird. In diesem Fall wird der \ib{ConnectionSate} auf \ib{SESSION\_NAME\_EXISTS}
gesetzt, sodass die Lobby darauf reagieren kann und eine entsprechende
Nachricht anzeigt.
Durch \ib{doReleaseName()} wird der angeforderte Name wieder freigegeben,
sodass er wieder verwendet werden kann.
\subsection{doAdvertise() und doCancelAdvertise()}
Das sogenannte \ib{Advertising} wird dazu benutzt um anderen Spielern den
Spielnamen mitzuteilen. Über einen einfachen Befehl wird die Mitteilung
gestartet und beendet. Dabei werden zum einen der Name der Session übergeben,
als auch das Transportmedium, in diesem Fall Wlan.
\subsection{doJoinSession() und doLeaveSession()}
Die Methode \ib{doJoinSession()} wird von den beitretenden
Teilnehmer ausgeführt. 
Im Codeausschnitt ~\ref{joinSession} zeigt die genauere Vorgehensweise beim
Bestreten einer Session.
\begin{lstlisting}[caption=Session beitreten,label=joinSession]		
Mutable.IntegerValue sessionId = new Mutable.IntegerValue();
bus.joinSession(sessionName,contactPort,sessionId,sessionOpts,sessionListener);
\end{lstlisting}
Die \ib{SessionOpts} definieren die für die Session wichtigen Parameter, wie das
Transportmedium, oder wie die Daten verschickt werden soll.
Bei der \ib{sessionId} handelt es sich um einen veränderbaren Integer Wert, der
bei der Ausführung der Methode zugewiesen wird. Schließlich wird noch ein \ib{SessionListener} als
Parameter übergeben. Dieser Listener leitet die Nachrichten an die
Observer, die im PTPHelper registriert sind, weiter. 
Falls die Verbindung erfolgreich war, wird anschließend ein \ib{SignalEmitter}
erstellt und dieser an den PTPHelper übergeben.
\subsection{doQuit()}
Schließlich gibt es noch die \ib{doQuit()} Methode, die aufgerufen wird,
wenn der Service beendet werden soll. Der Codeausschnitt ~\ref{quit} zeigt den
Inhalt dieser Methode.
\begin{lstlisting}[caption=doQuit Methode,label=quit]
backgroundHandler.disconnect();
backgroundHandler.getLooper().quit();
PTPHelper.getInstance().removeObserver(this);
this.stopSelf();
\end{lstlisting}
Es wird somit die Verbindung mit dem Bus geschlossen, falls sie noch offen ist.
Dann wird der \ib{BusThread} beendet, der an den \ib{BackgroundHandler}
gekoppelt war. Und zum Schluss wird der Service als Observer vom PTPHelper
entfernt und beendet.
