\chapter{Implementierung}
\section{Realisierung}  
Die PTPLibrary bietet eine
einfache Schnittstelle, über die eine Kommunikation mit allen Teilnehmern ermöglicht wird. Es ist
außerdem eine Activity implimentiert worden, welche das Erstellen und das
Verbinden zu Spielen übernimmt. Diese Activity besitzt eine graphische
Oberfläche und kann bei der Implementierung eines Spiels verwendet werden. Diese
Activity wird als \ib{Lobby} bezeichnet. Die Netzwerkverbindung von AllJoyn
läuft in einem seperaten Thread und ist daher mithilfe von \ib{Handlern} von dem \ib{UI-Thread} getrennt behandelt worden,
sodass sich die beiden Threads nicht behindern. Für die
Entwicklung der PTPLibrary und der Beispielanwendungen sind 2 Android
Smartphones verwendet worden. Das erste Gerät ist ein \ib{Samsung Galexy S3 GT-I9300} mit dem Betriebssystem Android 4.1.2.
Das zweite Gerät ist ein \ib{Sony Xperia Tipo ST21i}, das das Betriebssystem
Android 4.0.2 besitzt. Die Verbindung ist mithilfe eines \ib{WiFi AccessPoint} von
Android erstellt worden, zu dem sich das andere Gerät verbunden hat.
Um das Bibliothek benutzen zu können muss der
Entwickler nur die PTPLibrary als Bibliothek in sein Projekt einbinden. 

\section{PTPHelper}
Der PTPHelper ist eine Schnittstelle zwischen dem Spiel und
dem Hintergrundservice, der sich um die Verbindung kümmert.
Nach Abwägen mehrerer Möglichkeiten wie der Service, der sich um die
Verbindungstechnischen Abläufe kümmert, in die Applikation integriert werden
kann, ist die Wahl schließlich auf die Benutzung eines Singletons gefallen.
Alternativ ließe sich eine abstrakte Application benutzen, die der Entwickler in
seinem Projekt implementieren müsste, aber dies würde dem Entwickler auch eine
Architekturentscheidung aufzwingen. Der Entwickler kann entscheiden, wann der
Service gestartet wird und wie damit interagiert werden soll. So kann z.B.
der Einzelspielermodus vollkommen ohne der Benutzung des PTPHelpers realisiert
werden und erst beim Multiplayermodus wird der Service gestartet. Um den
PTPHelper zu initialisieren muss der Entwickler in seinem Code den folgenden Befehl aus dem
Codeausschnitt ~\ref{initHelper} ausführen.

\begin{lstlisting}[caption=Helper initialisieren,label=initHelper]
PTPHelper.initHelper("appName", context,MyLobby.class);
\end{lstlisting}

Der Parameter \ib{appName} ist der Name der Application und legt den Namen für
das \ib{BusAttachement} fest. Beim \ib{context} handelt es sich um die Android
Context Klasse, für das Starten des Services. Der \ib{MyLobby.class}
Parameter gibt an, welche Activity als Lobby gestartet werden soll. Daraufhin
kann über den Getter die initialisierte Instanz gefragt werden, wie im Codeausschnitt ~\ref{getInstance} gezeigt.
\begin{lstlisting}[caption=Getter für die initialisierte Instanz,label=getInstance] 
PTPHelper.getInstance();
\end{lstlisting}
Es muss jedoch beachten werden, das das Starten des Hintergrundservices ein
asynchroner Prozess ist, und der Hintergrundservice nach der Initialisierung
nicht vollständig gestartet gestartet ist.
Um den Zustand des Hintergrundservices zu erfahren kann über den Methodenaufruf,
wie im Codeausschnitt ~\ref{connectionState} gezeigt,dieser erfragt werden.
\begin{lstlisting}[caption=Verbindungstatus erfragen,label=connectionState]
PTPHelper.getIntance().getConnectionState();
\end{lstlisting}
Dabei handelt es sich um einen Integer, der die Werte CONNECTED=7
und DISCONNECTED=8 annehmen kann.
Damit der Service nur so lange läuft wie die Application wird der Service
an diese gebunden, siehe Codeausschnitt ~\ref{bindService}.\newpage

\begin{lstlisting}[caption=Service binden,label=bindService]
Intent service = new Intent(context, PTPService.class);
boolean bound = context.bindService(service,new PTPServiceConnection(),Service.BIND_AUTO_CREATE);
\end{lstlisting}
Bei dem \ib{PTPServiceConnection} Objekt handelt es sich um einen
Listener, der benachrichtigt wird, wenn die Verbindung zum Service aufgebaut
oder getrennt ist. Der Flag \ib{Service.BIND\_AUTO\_CREATE}
besagt, dass nach dem Binden des Services der Service automatisch über die
Methode \ib{onCreate()} erstellt werden soll.

Die PTPLibrary ist dazu ausgelegt nur im WLAN zu funkionieren, somit wird bei
der Initialisierung geprüft ob das Smartphone über eine WLAN Verbindung verfügt.
Dies wird über den \ib{WiFiManager} realisiert, wie im Codeausschnitt
~\ref{wifiManager} dargestellt.
\begin{lstlisting}[caption=WifiManager,label=wifiManager]
WifiManager wifiManager =(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
WifiInfo currentWifi = wifiManager.getConnectionInfo(); 
if((currentWifi==null || currentWifi.getSSID()== null || currentWifi.getSSID().isEmpty()){
	//Zeige, dass es keine WiFi Verbindung gibt
}
\end{lstlisting}
Im Falle dessen, dass es keine WLAN-Verbindung gibt, wird die Initialisierung
abgebrochen und der Service wird nicht gestartet.
Android ermöglicht es zusätzlich ein \ib{AccessPoint} zu erstellen, zu den sich
andere Smartphones verbinden können. Die Information über den Zustand des
AccesPoints ist jedoch keine öffentliche Methode des WiFi-Manangers, sodass
diese Information nur über Java-Reflection erfragt werden kann. Wie das
funktioniert wird im Codebeispiel ~\ref{reflect} verdeutlicht.

\begin{lstlisting}[caption=Access Point Status erfragen,label=reflect]
Method method = wifiManager.getClass().getMethod("isWifiApEnabled");
state = (Boolean) method.invoke(wifiManager);
\end{lstlisting}
Nachdem der PTPHelper initialisiert ist und der Service gestartet, kann
über den PTPHelper den Service mitgeteilt werden z.B. sich zu einer Session zu
verbinden oder eine Session zu erstellen.
Dies geschieht über Methodenaufrufe, wie im Beispiel ~\ref{clientHost}
gezeigt.

\begin{lstlisting}[caption=Host/Client Sessions Handhabung,label=clientHost]
//Host
PTPHelper.getInstance().setHostSessionName(name)
PTPHelper.getInstance().hostStartSession()
...
//Client
PTPHelper.getInstance().setClientSessionName("sessionName");
PTPHelper.getInstance().joinSession();
\end{lstlisting}

Der PTPHelper erlaubt es zusätzlich verschiedene Observer zu registrieren, um
auf möglichliche Events entsprechend reagieren zu können.
Zu den Observern gehören die Interfaces LobbyObserver, BusObserver,
SessionObserver und der HelperObserver, die der Entwickler selber implementieren
kann.
Zu den LobbyObservern gehört z.B. auch die AbstractLobbyActivity und
implementiert die Methode \ib{conncetionStateChanged(int state)},
die aufgerufen wird, wenn der Service eine Verbindung aufbaut oder trennt.
Der BusObserver hört auf den Bus selbst und definiert die folgenden Methoden:
\begin{lstlisting}[caption=BusObserver]
public void foundAdvertisedName(String sessionName);
public void lostAdvertisedName(String sessionName);
public void busDisconnected();
\end{lstlisting}
Durch die Implementierung des BusObservers kann auf das
Öffnen und Schließen der Spiele reagiert werden, falls die in der PTPLibrary
vorimplementierte Behandlung, für den Entwickler nicht ausreichend ist. Die \ib{foundAdvertisedName} Methode wird
aufgerufen, wenn eine neue Session gefunden wurde und \ib{lostAdvertisedName}
wenn eine bekannte Session geschlossen wurde oder nicht mehr erreichbar ist.
Die \ib{busDisconnected} Methode wird aufgerufen, wenn das BusAttachement
keine Verbindung zum Bus mehr hat. Der BusObserver ist z.B.
im PTPHelper schon einmal implementiert und er sorgt dafür, dass neu erstellte Spiele in einer Liste
\ib{foundSessions} gespeichert und entsprechend auch
entfernt werden. Dies ist notwendig um in der Lobby alle gerade offenen Spiele
anzeigen zu können.
\newline
Der SessionObserver definiert Methoden um auf Events zu reagieren,
die im Bezug zu einer Session stehen. Der Codeausschnitt ~\ref{sessionObserver}
zeigt die Methoden, die das Interface definiert.
\newpage
\begin{lstlisting}[caption=SessionObserver,label=sessionObserver]
public void memberJoined(String uniqueId);
public void memberLeft(String uniqueId);
public void sessionLost();
\end{lstlisting}
Dies ermöglicht es dem Entwickler bestimmte Aktionen auszuführen, falls neue
Spieler sich zur Session verbinden \ib{(memberJoined)}, sich von der Session
trennen \ib{(memberLeft)} oder man selbst die Verbindung zur Session verliert
\ib{(sessionLost)}. Schließlich gibt es noch den \ib{ServiceHelperObserver},
der z.B.vom PTPService implementiert wird. Dieser Observer hört auf den
Helper, der über die Methode \ib{doAction(int action)} verschieden Aktionen
mitteilt. So hat z.B. der Methodenaufruf
aus Codeausschnitt ~\ref{joinSession}
\begin{lstlisting}[caption=verbinde zur Session,label=joinSession]
PTPHelper.getInstance().joinSession();
\end{lstlisting}
zur Folge, dass der PTPHelper den Service über den Observer mitteilt sich zu
einer Session zu verbinden. 
Die oben genannten Observer sind mithilfe eines \ib{Handlers} vom
Hintergrundthread abgekoppelt. Der Entwickler muss dadurch bei der
Implementierung der Observer sich keine Gedanken um Threadkollisionen machen.
Der PTPHelper besitzt einen \ib{BackgroundHandler}, der im
Konstruktor erstellt und an den UI Thread gekoppelt wird, siehe Codeausschnitt 
~\ref{uiBackgroundThread}.
\begin{lstlisting}[caption=UI Thread BackgroundHandler,label=uiBackgroundThread]
backgroundHandler = new BackgroundHandler(Looper.getMainLooper());
\end{lstlisting}
Sobald der Hintergrundprozess aus dem PTPService die Observer benachrichtigen
will und z.B. die Methode \ib{notifyMemberJoined(String)} ausführt, wird diese
Nachricht an den \ib{BackgroundHandler} geleitet.
Der \ib{BackgroundHandler} reagiert über die Methode
\ib{handleMessage(Message)} auf die Nachricht, indem jedoch die Methode auf dem
UI Thread ausgeführt wird.
Es gibt außerdem noch den \ib{DataListener}. Dieses Inteface definiert die
Methode \ib{dataSentToAllPeers(String,int,String[])}. Diese Methode wird
jedesmal aufgerufen, wenn eine Nachricht an alle Smartphones geschickt wird. Die
Implementierung und die registierung des Listeners ist notwendig für das
Empfangen von Daten. Die Methode \ib{sendDataToAllPeers(int arg,String[] data)},
die beim PTPHelper implementiert ist, erlaubt es Daten an alle zu der Session
verbundenen Spielern zu verschicken. AllJoyn baut auf einem \ib{DBus System} auf
und unterliegt somit dessen Specificationen\cite{dbus}. Es ist daher zubeachten,
dass der String, der verschickt wird, nur eine \ib{UTF-8} formatierung besitzen
darf.
Schließlich gibt es noch das \ib{SessionJoinRule} Interface, das die
\ib{boolean canJoin(String joinersUniqueId)} Methode definiert.
Darüber kann der Entwickler bestimmte Regeln festlegen, die darüber entscheiden,
ob ein Mitspieler sich zu einem Spiel verbinden kann oder nicht. Dabei werden
beim Verbinden eines Spielers alle diese Regeln durchlaufen und nur wenn alle
davon \ib{true} zurückliefern, darf der Spieler beitreten.


\section{LobbyActivity}
Die LobbyActivity ist eine abstracte Klasse, die eine Grundfunktionalität
mitbringt. Die Lobby, die die LobbyActivity implementiert, zeigt die Abbildung
~\ref{fig:lobby}.
\begin{wrapfigure}{r}{0.5\textwidth}
   \centering
   \includegraphics[width=0.48\textwidth]{chapter3/lobby}
   \caption[Von Text umflossenes Bild]{LobbyActivity}
   \label{fig:lobby}
 \end{wrapfigure}  
Sie bietet eine UI-Oberfläche, die es ermöglicht einen Namen für den Spieler
anzugeben, ein Spiel zu eröffnen oder sich zu einem Spiel zu verbinden. Auf dem
Bild sieht man die zwei Einträge \ib{game} und
\ib{game2} bei dem es sich um zwei offene Spiele handelt. Für die Verbindung
zu den Spiele, muss nur der entsprechende Name berührt werden. Die
LobbyActivity ist eine abstrakte Klasse, daher müssen die Methoden
\ib{getJoinSessionView} und \ib{getHostSessionView} imlementiert werden.
Bei diesen Methoden handelt es sich um eine Definition der Klassen, die die
Activities beschreiben, die geöffnet werden soll, wenn eine gegebene Aktion
durchgeführt wird. Das heißt wenn ein neues Spiel erstellt wird, so muss die
Methode \ib{getHostSessionView()} die Activity Klasse definieren,
die geöffnet werden soll, wenn ein Spiel geöffnet wird.Die beiden Methoden
können auch die selbe Activity übergeben, wenn die Activity die
logische Auseinandersetzung mit dem Host und Clienten übernimmt.

\section{PTPService}
Die PTPService Klasse besitzt die eigentliche Funktionalität der Bibliothek und
ist dafür verantwortlich die Verbindung mit dem Bus zu erstellen und diese
entsprechend zu konfigurieren. Der PTPService ist eine Unterklasse von Service aus dem
Android SDK, die im Hintergrund gestartet wird und in einem seperaten Thread
läuft. Der Service bietet keine direkten Zugriff auf die Instanz, und somit muss
die Kommunikation mit einem Nachrichtensystem realisiert werden. Android bietet
hierfür ein Nachrichtensystem an, um mit dem Service zu kommunizieren.
Die Verwendung des Nachrichtensystems von Android beschränkt sich jedoch auf
die Verwendung des \ib{Handlers}.
Wenn der PTPService erstellt wird, wird seine \textit{\textbf{onCreate()}}
Methode aufgerufen, in der der Service sich als Observer beim PTPHelper
registriert. Daraufhin kann der PTPService Nachrichten erhalten um Aktionen
auszuführen.
Damit das Bussystem von AllJoyn benutzt werden kann, muss dieser initialisiert
werden. Das geschieht über einen Befehlsaufruf, der im Codeausschnitt
\ref{initDaemon} dargestellt ist. 
\begin{lstlisting}[caption=Daemon initialisieren,label=initDaemon] 
org.alljoyn.bus.alljoyn.DaemonInit.PrepareDaemon(getApplicationContext());
\end{lstlisting}
Der AllJoyn Daemon ist ein Hintergrundprozess, der sich um die
verbindungstechnischen Abläufe kümmert. 
Daraufhin wird der HandlerThread gestartet, der sich um die Nachrichten von
PTPHelper kümmert. Dabei wird wie beim PTPHelper ein BackgroundHandler
initialisiert. Der BackgroundHandler wird jedoch an einen neu erstellten Thread
gekoppelt. Der PTPHelper teilt über die Observer dem PTPService mit, welche
Aktionen ausgeführt werden müssen.

In den nächsten Unterkapiteln wird auf die einzelnen Methoden eingegangen,
die sich im PTPService befinden und vom BackgroundHandler ausgeführt werden.
\subsection{doConnect() und doDisconnect()}
Die \ib{doConnect()} Methode ist dafür verantwortlich eine
Verbindung mit dem Bus herzustellen indem es ein BusAttachement erstellt, den
SignalHandler und das BusObject registriert. Der Codeauschnitt
~\ref{newBusAttachement} zeigt wie das BusAttachement erstellt wird.
\begin{lstlisting}[caption=BusAttachement erstellen,label=newBusAttachement]
bus = new BusAttachment(package + "appName",BusAttachment.RemoteMessage.Receive);
\end{lstlisting}
Dabei wird als erster Parameter der BusAttachement Name übergeben. 
Es ist möglicht mit AllJoyn mehrere Anwendungen auf den selben Smartphone laufen
zu lassen. Um jedoch die einzelnen BusAttachements den Applicaiton zuweisen zu
können, werden sie mit einem Namen versehen.
Der zweite Parameter bestimmt, ob eingehende Nachrichten empfangen und behandelt
oder verworfen werden sollen.
Danach wird in der Methode der BusListener registriert, der dafür zuständig
ist auf geöffnete Spiele zu reagieren. Diese Nachrichten werden dann an die
Observer weiter geleitet, siehe Codeausschnitt ~\ref{busListenerImpl}.
\begin{lstlisting}[caption=BusListener Nachrichten,label=busListenerImpl]
@Override
public void foundAdvertisedName(String fullName, short transport, String namePrefix) {
	if(namePrefix.equals(packageName))
		PTPHelper.getInstance().notifyFoundAdvertisedName(getSimpleName(fullName));
};
@Override
public void lostAdvertisedName(String fullName, short transport, String namePrefix) {
	if(namePrefix.equals(packageName))
		PTPHelper.getInstance().notifyLostAdvertisedName(getSimpleName(fullName));
}
@Override
public void busDisconnected() {
	PTPHelper.getInstance().notifyBusDisconnected();
}
\end{lstlisting}
\newpage
Der Packagename ändert sich innerhalb der Anwendung nicht, daher wird nur der
Sessionname an die Observer weitergeleitet.
Daraufhin wird der BusObject registriert, das im Codeausschnitt
~\ref{regBusObject} zu sehen ist.
\begin{lstlisting}[caption=BusObject registrieren,label=regBusObject]
BusObject busObject = PTPHelper.getInstance().getBusObject(); 
status = bus.registerBusObject(busObject, objectPath+ "/" + getDeviceID());
\end{lstlisting}
Dabei wird ein BusObject genommen, der bei der Initialisierung vom PTPHelper
erstellt wurde. Der BusObject wird später dazu benötigt einen sogenannte
SignalEmmiter zu bekommen, über den Nachrichten an alle Smartphones geschickt
werden kann.
Der Pfad, unter den der BusObject abgelegt wird, muss innerhalb des BusSystems
einzigartig sein, um Konflikte zwischen den BusObjekten zu vermeiden. Der Pfad
 ist wie bei einen Dateisystem organisiert und wird über das
 Slashzeichen getrennt. Um die Einzigartigkeit eines Pfaded für jedes Bus
 Objektes zu ermöglichen, wurde als Teilpfad die \ib{Geräte ID} benutzt. 
 Der Codeausschnitt ~\ref{deviceID} zeigt, wie die Geräte ID erfragt werden
 kann.
\begin{lstlisting}[caption=Geräte ID,label=deviceID]
private String getDeviceID(){
	TelephonyManager telephonyManager = (TelephonyManager) getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
	return telephonyManager.getDeviceId();
}
\end{lstlisting}
Jedoch muss dazu im AndroidManifest die notwendige Erlaubniss
\ib{READ\_PHONE\_STATE} hinzugefügt werden.
Darufhin wird die \ib{bus.connect()} Methode aufgerufen, um mit dem
Bus zu verbinden. Wenn die Verbindung erfolgreich war, wird der SignalHandler registriert.
Der SignalHandler wird beim PTPHelper erstellt, und er definiert eine Methode.
\begin{lstlisting}[caption=SignalHandler Methode,label=signalMethod]
@BusSignalHandler(iface = "de.ptpservice.PTPBusObjectInterface", signal = "SendDataToAllPeers")
public void SendDataToAllPeers(String sentFrom,int arg, byte[] data) {
	notifyDataListenersAllPeers(sentFrom,arg,data);
}
\end{lstlisting}
Der Codeausschnitt \ref{signalMethod} zeigt die Methode, die für
die Kommunikation zwischen den Smartphones benutzt wird. Die Implementierung der
Methode im SignalHandler, bedeutet dass diese Methode aufgerufen wird, wenn eine
Nachricht an jedes Smartphone geschickt wird. In Zeile 3, werden die empfangenen
Daten an die \ib{DataListener} geschickt. Schließlich wird die UniqueID des
BusAttachements an den PTPHelper übergeben, die einen busweiten einzigartigen
String darstellt.
Die \ib{doDisconnect()} Methode ist dafür verantworlich
alle Handler und das BusObject abzumelden und die Verbindung zu trennen.

\subsection{doStartDiscovery() und doStopDiscovery()}
Die Methode \ib{doStartDiscovery()} wird am Anfang, nach dem
die Verbindung aufgebaut ist, ausgeführt. Die Methode ist dafür verantworlich
dem BusAttachement mitzuteilen nach offene Spielen zu suchen und diese dem
Observer mitzuteilen. Dies geschieht über den einfachen Methodenaufruf
\ib{bus.findAdvertisedName(packageName)}.
Wobei der \ib{packageName} das Prefix für den Name darstellt. Somit
würde das BusAttachement auf alle offene Spiele reagieren, welche den Prefix mit
dem \ib{packageName} haben. Wenn das Entdecken von offenen
Spielen beendet werden soll, kann die Methode
\ib{doStopDiscovery()} ausgeführt werden, die die Methode
\ib{bus.cancelFindAdvertisedName(packageName)} ausführt.

\subsection{doBindSession() und doUnbindSession()}
Die \ib{doBindSession()} Methode wird dafür benötigt, um eine neue Session zu
erstellen. Dabei werden unterschiedliche
Konfigurationen vorgenommen, die zur Erstellung einer Session notwendig sin. Zum
einen muss der \ib{SessionPort} festgelegt und die Transportparameter
konfiguriert werden.
Bei den Transportparametern handelt es sich darum, ob die Verbindung über
Bluetooth, WifiDirect oder Lan zugelassen werden soll, ob es sich hierbei um
eine Multipoint Session handelt, ob die Session Beitreter von außerhalb des lokalen Gerätes befinden dürfen und ob die Daten roh oder als
Nachrichten verpackt verschickt werden soll.
Die Konfigurationen sind im Codeausschnitt ~\ref{portConfig} aufgeführt.
\begin{lstlisting}[caption=Sessionkonfiguration,label=portConfig]
Mutable.ShortValue mutableContactPort = new Mutable.ShortValue(contactPort);
SessionOpts sessionOpts = new SessionOpts(SessionOpts.TRAFFIC_MESSAGES,
				true, SessionOpts.PROXIMITY_ANY, SessionOpts.TRANSPORT_WLAN);		
\end{lstlisting}
Als \ib{contactPort} wird der Standartwert 100 genommen. Dieser kann jedoch beim
PTPHelper über die Methode \ib{setContactPort} verändert werden. Neben den
Konfigurationsparametern benötigt man auch einen \ib{SessionPortListener}, welcher sich um die Verbindungsanfragen von anderen
Geräten kümmert, sowie bei einer erfolgreichen Verbindung die nötigen Schritte
einleitet. Der \ib{SessionPortListener} implementiert eine Methode, die im
Codeausschnitt ~\ref{acceptJoiner}:
\begin{lstlisting}[caption=SessionPortListener implementierung,label=acceptJoiner] 
public boolean acceptSessionJoiner(short
sessionPort, String joiner, SessionOpts sessionOpts) {
		if(sessionPort == contactPort){					
			return PTPHelper.getInstance().canJoin(joiner);
		}
		return false;
}
\end{lstlisting}
Dabei wird zuerst geprüft ob der SessionPort übereinstimmt und danach werden die
möglicherweise definierten \ib{SessionJoinRules} durchlaufen. Erst wenn alle die
Regeln \ib{true} zurückliefern wird das Beitreten zur Session gewährt. 

\begin{lstlisting}[caption=Als Host den SignalEmitter bekommen,label=hostSignalEmitter] 
public void sessionJoined(short sessionPort,int sessionId,String joiner){
if(firstJoiner){
	firstJoiner = false;
	hostSessionId = sessionId;
	SignalEmitter emitter = new SignalEmitter(PTPHelper.getInstance().getBusObject(), sessionId, SignalEmitter.GlobalBroadcast.Off);
	hostInterface = emitter.getInterface(PTPHelper.getInstance().getBusObjectInterfaceType());
	PTPHelper.getInstance().setSignalEmiter(hostInterface);
	PTPHelper.getInstance().notifyMemberJoined(joiner);
	bus.setSessionListener(sessionId, new PTPSessionListener());
	}
}
\end{lstlisting}
Die zweite Methode umfasst ein etwas komplizierteres Szenario.
AllJoyn erlaubt es nicht einen Host, welcher eine Session bindet, sich zu dieser auch zu verbinden.
\newpage
Um jedoch als Host auch am Spiel teilnehmen zu können wird dieses Verhalten
durch einen Umweg erreicht.
Durch die Methode aus dem Codeausschnitt ~\ref{hostSignalEmitter} erfährt man
die bis dahin unbekannte \ib{SessionID}, da sie durch das Binden der Session nicht mitgeteilt wird. Daraufhin kann man mit
der \ib{SessionID} einen \ib{SignalEmitter} erstellen, der als Endpunkt fungiert
und das Verschicken von Nachrichten ermöglicht. Zusätzlich lässt sich der
\ib{PTPSessionPortListener} an die Session binden. Somit ist es
 dem Host nur möglich zu funktionieren, wenn sich der erste
Teilnehmer verbunden hat.Zum schluss wird
der \ib{SessionPortListener} beim Bus registriert und eine Session erstellt,
siehe Codeausschnitt ~\ref{bindSessionPort}.
\begin{lstlisting}[caption=Session erstellen,label=bindSessionPort]
bus.bindSessionPort(mutableContactPort, sessionOpts, sessionPortListener);
\end{lstlisting}
In der Methode \ib{doUnbindSession()} wird durch den einfachen Methodenaufruf
\ib{bus.unbindSessionPort(contactPort)}, die Session, welche an den
\ib{contactPort} gebunden ist, geschlossen.

\subsection{doRequestName() und doReleaseName()}
Die Methoden \ib{doRequestName()} und \ib{doReleaseName()} sind dazu vorgesehen,
um die Sessionnamen, die später durch das \ib{Advertising} an andere
Spieler mitgeteilt werden können, vom Bus zugewiesen zu bekommen. Es dürfen
Sessionnamen nur dann an Andere mitgeteilt werden, wenn diese vom Bus auch
zugewiesen worden sind. Der Codeausschnitt ~\ref{requestName} zeigt den
Methodenaufruf.
\begin{lstlisting}[caption=Name für Session anfordern,label=requestName]
bus.requestName(packageName + "." +PTPHelper.getInstance().getHostSessionName(),
				BusAttachment.ALLJOYN_REQUESTNAME_FLAG_DO_NOT_QUEUE);
\end{lstlisting}
Als Prefix der \ib{packgeName} verwendet und der \ib{HostSessionName}
ist der Name, der in der Lobby hinterlegt und beim PTPHelper abgespeichert
wurde. Der zweite Parameter besagt, dass bei vorhanden Namen nichts unternommen
werden soll. Eine andere Möglichkeit bestehe nämlich den vorhandenen Namen
einfach zu ersetzen.
Durch \ib{doReleaseName()} wird der Name dann wieder freigegeben, sodass er
wieder von Anderen verwendet werden kann.
\subsection{doAdvertise() und doCancelAdvertise()}
Das sogenannte \ib{Advertising} wird dazu benutzt um anderen Spielern den
Spielnamen mitzuteilen. Über einen einfachen Befehl wird die Mitteilung
gestartet und beendet. Zur Verdeutlichung siehe Codeausschnitt
~\ref{advertising}.
\begin{lstlisting}[caption=Session Name mitteilen,label=advertising]
String sessionName=packageName+"."+PTPHelper.getInstance().getHostSessionName();
bus.advertiseName(sessionName, SessionOpts.TRANSPORT_WLAN); ...
String sessionName=packageName+"."+PTPHelper.getInstance().getHostSessionName();
bus.cancelAdvertiseName(sessionName,SessionOpts.TRANSPORT_WLAN);
\end{lstlisting}
Dabei werden zum einen der Name des Spiels übergeben, als auch das
Transportmedium, in diesem fall Wlan.
\subsection{doJoinSession() und doLeaveSession()}
Die Methode \ib{doJoinSession()} ist sogesehen das entsprechende Gegenbeispiel
zu der \ib{doBindSession()} Methode. Diese Methode wird von den beitretenden
Teilnehmer ausgeführt. 
Im Codeausschnitt ~\ref{joinSession} sieht man die genauere Vorgehensweise beim
Bestreten einer Session.
\begin{lstlisting}[caption=Session beitreten,label=joinSession]
String sessionName = packageName + "."+PTPHelper.getInstance().getSessionName();
SessionOpts sessionOpts = new SessionOpts(SessionOpts.TRAFFIC_MESSAGES, true,
SessionOpts.PROXIMITY_ANY, SessionOpts.TRANSPORT_WLAN);
		
Mutable.IntegerValue sessionId = new Mutable.IntegerValue();
bus.joinSession(sessionName, contactPort, sessionId,sessionOpts, sessionListener);
\end{lstlisting}
Hierbei werden über die /ib{SessionOpts} wie bei der \ib{doBindSession()}
Methode die ganzen Parameter für die Session festgelegt. Bei der \ib{sessionId}
handelt es sich um einen veränderbaren integer Wert, welcher bei der Ausführung
der Methode zugewiesen wird. Schließlich wird noch ein \ib{SessionListener} als
Parameter übergeben. Auch dieser Listener leitet die Nachrichten an die
Observer, welche im PTPHelper abgespeichert sind, weiter. 
Jedoch wird die Information über die SessionId dem PTPHelper nicht
mitgeteilt, da sie für den Entwickler, welcher den Observer gegebenenfalls implementiert, nicht von
Interesse sein sollte.
Falls die Verbindung erfolgreich war wird anschließend ein \ib{SignalEmitter}
erstellt und dieser an den PTPHelper übergeben, wie im Codeausschnitt
~\ref{clientSignalEmitter} aufgeführt.
\begin{lstlisting}[caption=SignalEmitter bekommen als Client,label=clientSignalEmitter] 
SignalEmitter emitter = new SignalEmitter(PTPHelper.getInstance().getBusObject(), clientSessionId, SignalEmitter.GlobalBroadcast.Off); Object clientInterface = emitter.getInterface(PTPHelper.getInstance().getBusObjectInterfaceType()); PTPHelper.getInstance().setSignalEmitter(clientInterface);
PTPHelper.getInstance().setConnectionState(PTPHelper.SESSION_JOINED);
\end{lstlisting}
\subsection{doQuit()}
Schließlich gibt es noch die \ib{doQuit()} Methode, die aufgerufen wird,
den der Service beendet werden soll. Der Codeausschnitt ~\ref{quit} zeigt den
Inhalt dieser Methode.
\begin{lstlisting}[caption=doQuit Methode,label=quit]
backgroundHandler.disconnect();
backgroundHandler.getLooper().quit();
PTPHelper.getInstance().removeObserver(this);
this.stopSelf();
\end{lstlisting}
Es wird somit die Verbindung mit dem Bus geschlossen, falls sie noch offen ist.
Dann wird der \ib{BusThread} beendet, welcher an den \ib{BackgroundHandler}
gekoppelt war. Und zum Schluss wird der Service als Observer vom PTPHelper
entfernt und beendet.
