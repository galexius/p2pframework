\chapter{Implementierung}

Es gibt viele verschiedene Spielprinzipien und daher sollte soweit es geht mit
dem PTPRahmenwerk den späteren Entwicklern so viel Freiheit gelassen werden wie
möglich.
Jedoch gibt es viele Abläufe, die sich immer wieder wiederholen. So hat man den
typschen Ablauf, dass man das Spiel startet und man sich in einer Lobby
befindet. Danach kann man entweder ein Spiel erstellen und sich zu einem bereits
erstellten Spiel verbinden. Diesen Ablauf wird durch das PTPRahmenwerk
übernommen, sodass man sich hinterher darum nicht mehr kümmern muss.
Der Entwickler hätte dann nur noch die Aufgabe sich um die Activities zu
kümmern, die das Spiel representieren und die Verbindung und Vermittlung würde
das PTPRahmenwerk übernehmen. Um das Framework benutzen zu können müsste der
Entwickler dann nur noch eine Jar-Datei als Bibliothek in sein Projekt einbinden und er
könnte loslegen.

\section{PTPHelper}
Der PTPHelper ist eine Schnittstelle zwischen dem Spiel und
dem Hintergrundservice, welcher sich um die Verbindung kümmert.
Nach Abwägen mehrerer Möglichkeiten wie man den Service, welcher sich um die
Verbindungstechnischen Abläufe kümmert, in die Applikation integrieren kann, ist
die Wahl schließlich auf die Benutzung eines Singletons gefallen. Zwar ließe
sich eine abstrakte Application benutzen, die der Entwickler in seinem Projekt
implementieren müsste, aber dies würde dem Entwickler auch eine
Architekturentscheidung aufzwingen. Außerdem ist eine zu enge Bindung an das
Android Rahmenwerk unvorteilhaft, da sich dessen API recht oft ändert und die
Entwicklung in der Zukunft erschweren kann. Durch das Singleton kann der
Entwickler entscheiden, wann er den Service startet und wie er damit
interagieren will. So kann er z.B.
den Einzelspielermodus vollkommen ohne den Helper realisieren und erst bei Multiplayermodus den Service starten. Um den PTPHelper zu
initialisieren muss der Entwickler in seinem Code den Folgenden Befehl ausführen:

\begin{lstlisting}
PTPHelper.initHelper(MyInterface.class, context, proxyObject, signalHandler, MyLobby.class);
\end{lstlisting}

Daraufhin kann er über den Getter an die initialisierte Instanz kommen.

\begin{lstlisting}
PTPHelper.getInstance();
\end{lstlisting}
Bei der Initialisierung wird der P2PService im Hintergrund gestartet welcher die
Verbindung zum Bussystem aufbaut, daher sind die ganzen Parameter notwendig. Es
wird zum einen die Interface Klasse benötigt über das die Kommunikation mit den anderen Peers realisiert wird und gibt den Typ
für die generische P2PHelper Klasse vor.
Der context ist die Activity oder die Application an die der Service gebunden wird. Der
MyLobby.class Paramater übergibt die Klasse, die die AbstractLobbyActivity
aus dem PTPRahmenwerk implementiert. Die LobbyActivity ist an den Service
gebunden, da sie über den Zustand der Verbindung benachrichtigt wird. Die
genauere Funktionalität der Lobby wird später noch erklärt. Das ProxyObject und
der SignalHandler müssen gleich bei der Initialisierung übergeben werden, da sie
bei der Verbindung mit dem Bus beim Bus registriert werden müssen, damit sie
gleich auf Nachrichten reagieren können und das ProxyObject gleich einem
konkreten End-punkt zugewiesen werden kann.

Das PTPRahmenwerk ist dazu ausgelegt nur im WLAN zu funkionieren, somit wird bei der
Initialisierung geprüft ob das Gerät über eine WiFi Verbindung verfügt. 
Dies wird über den WiFiManager realisiert.

\begin{lstlisting}
WifiManager wifiManager =(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
WifiInfo currentWifi = wifiManager.getConnectionInfo(); 
if((currentWifi==null || currentWifi.getSSID()== null || currentWifi.getSSID().isEmpty()){
	//Show Message there is no WiFi-Connection
}
\end{lstlisting}
Im Falle dessen, dass es keine WiFi-Verbindung gibt, wird die Initialisierung
abgebrochen und der Service wird nicht gestartet.
Android ermöglicht es zusätzlich ein AccessPoint zu erstellen, worüber sich
andere Geräte verbinden können. Die Information über diesen Zustand wird jedoch
nicht ohne Weiteres über den WiFi-Mananger herausgegeben, sodass man an diese
Information nur über Java-Reflection gelangt:

\begin{lstlisting}

Method method = wifiManager.getClass().getMethod("isWifiApEnabled");
state = (Boolean) method.invoke(wifiManager);

\end{lstlisting}
Nach dem jedoch der Helper initialisiert ist und der Service gestartet, kann man
über den Helper den Service mitteilen sich z.B. zu einem Channel zu verbinden
oder einen Channel zu erstellen.
Dies geschickt über einfache Methodenaufrufe:

\begin{lstlisting}
PTPHelper.getInstance().setHostChannelName(name)
PTPHelper.getInstance().hostStartChannel()
...
PTPHelper.getInstance().setClientChannelName("channelName");
PTPHelper.getInstance().joinChannel();

\end{lstlisting}

\section{LobbyActivity}
 

\section{PTPService}

 
