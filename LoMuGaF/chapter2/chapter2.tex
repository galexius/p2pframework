\chapter{Grundlagen}

\section{Konzepte} \label{sec:concept}

  Die PTPLibrary basiert auf dem \ib{Peer-to-Peer} Prinzip  und benötigt
  deswegen keinen Server. Jedes Gerät ist gleichgestellt und interagiert über einen
  \ib{Bussystem} mit den anderen Geräten. Über eine Schnittstelle kann der
  Entwickler Nachrichten an alle anderen Teilnehmer versenden und eingehende Nachrichten
  empfangen.
\begin{wrapfigure}{r}{0.5\textwidth}
   \centering
   \includegraphics[width=0.48\textwidth]{chapter1/architect}
   \caption{Architektur-Konzept}
   \label{fig:architec}
\end{wrapfigure}
  Jedes der Smartphones hat eine identische Version des Spiels, sodass die
  Organisation im Spiel realisiert wird. Wie in der Abbildung
  ~\ref{fig:architec} zu sehen, kann jedes Spiel auf einem Smartphone mit den
  anderen Smartphone eine Verbindung über einen \ib{AllJoyn Bussystem}
  ~\ref{subsec:bussystem} aufbauen. Das Spiel selbst interagiert nur mit der
  \ib{PTPLibrary}, welche selbst eine logische Verbindung aufbaut und die
  Nachrichten entsprechend weiterleitet. Ein Spieler kann eine Session
  erstellen, zu der sich die anderen Spieler verbinden, um an der
  Spielrunde teilnehmen zu können. Durch die Session wird die Möglichkeit gegeben mehrere Spiele simultan im selben Netzwerk zu spielen.
  
  \section{Peer-to-Peer} \label{sec:ptp}
  Peer-to-Peer kommt vom englischen Wort peer=Gleichberechtigter und entspricht
  somit einem Netzwerk aus gleichberechtigten Teilnehmern. Durch das Weglassen
  eines Servers, ist die Organisation den Peers überlassen.
  \newpage
\begin{figure}[hbt!]
\centering
	\begin{subfigure}[b]{0.3\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{chapter2/Server-based-network}
	    \caption{Server}
	    \label{fig:server}
    \end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{chapter2/P2P-network}
	    \caption{Peer-to-Peer}
	    \label{fig:p2p}
    \end{subfigure}
    \caption{(a) Server basiertes vs. (b) Peer-to-Peer basiertes Netzwerk}
    \label{ptpserver}
\end{figure} 
 Die Bilder \ref{ptpserver} \ib{a} und \ib{b} zeigen die Unteschieden zwischen
 einem Serverbasierten und einem Peer-to-Peer Netzwerk.
 Durch das Weglassen eines fest zugeordneten Servers, wird eine
 höhere Flexibilität erreicht, sodass nur Peers benötigt werden um das Spiel zu
 spielen.
 Durch ein Peer-to-Peer Netzwerk entstehen jedoch auch Probleme und
 Herausforderungen.
 Bei einem serverbasiertem Spiel wird der Zustand des Spiels auf
 dem Server geregelt und alle zu dem Server verbundenen Geräte brauchen den
 Server nur nach diesen Zustand zu fragen. Rechenintensive
 Aufgaben können vom Server übernommen werden und so die einzelnen Smartphones
 entlasten.
 Bei einem Peer-to-Peer System hingegen muss der Zustand von jedem einzelnen
 Smartphone ermittelt und mit den anderen Smartphones synchonisiert werden. Dies
 hat einen höheren Ressourcenaufwand und kann die Anzahl der möglichen Teilnehmer limitieren. Jedoch ist es auch vom Anwendungfall abhängig, denn ein entsprechendes Gegenbeispiel für eine hohe
 Peersanzahl zeigten Tauschbörsen wie Torrent oder Napster, um nur zwei bekannte
 Beispiele zu nennen. Die Entwicklern müssen zum einen entscheiden wie viele
 Spieler maximal zulässig sind und somit auch die Anforderung für die Komplexität des Spiel setzen.
  \section{Android SDK} \label{sec:andsdk}
  \begin{wrapfigure}{l}{0.2\textwidth}
   \centering
   \includegraphics[width=0.2\textwidth]{chapter2/android}
\end{wrapfigure} 
  Android ist das Linux-basierte Betriebssystem für mobile Endgeräte, welches
  von Google 2011 offiziell zur Verfügung gestellt wurde. Android selbst gilt
  als sogenannte freie Software, das bis auf den System-Kern unter der
  Apache-Lizens steht. Diese Tatsache unter Anderen ermöglichte eine rasante
  Verbreitung dieses Betriebsystems auf vielen Geräten unterschiedlicher
  Hersteller. Somit waren im Mai 2013 etwa 900 Millionen Android End-Geräte
  aktiviert \cite{android900} und es wird klar, dass die Popularität dieses
  Betriebssystem immer mehr zunimmt. Google hat eine
  Entwicklungswerkzeugsammlung zur Verfügung gestellt, welche die Entwicklung von Applikationen für Android
 möglichst einfach gestallten soll. Bei dieser Werkzeugensammlung handelt es
 sich um das Android SDK, das auch als das Android Developer Tool kurz ADT
 verfügbar ist. ADT ist ein Plugin für das mittlerweile weit verbreitete
 Entwicklungsumgebung Eclipse, welche die Entwicklung und die Übertragung der
 Applikation auf das Gerät problemlos ermöglicht.
 Weiterhin bringt das Android SDK einen Emulator mit sich, das das Testen von
 Apps unter unteschiedlichen Konfigurationen ermöglicht, ohne dass man ein
 Android-Gerät benötigt. Vorallem ermöglicht das Android SDK die Entwicklung der Apps in der Programmiersprache Java.
 Als Nächstes wird auf die einzelne Grundlagen von Android SDK eingegangen um
 die Funktionalität dieser zu beschreiben.
 
 \subsection{Activity}
Eine Activity ist eine Klasse, die die Erstellung von einzelnen UI-Fenstern
übernimmt.
Die meisten Apps in Android bestehen aus mehreren Activities, welche
mit einander verbunden sind. 
Eine selbst erstellte Activity muss von der Klasse \ib{Activity} erben.
Zusätzlich muss die Methode \textbf{\textit{onCreate()}} in dieser Klasse
überschrieben werden. Diese Methode wird jedesmal aufgerufen wenn die Activity
erstellt wird und auf dem Bildschirm angezeigt werden soll. In diese Methode
könne Aufrufe von Fenstern kommen, die die UI beinhalten, oder andere
Operationen die beim Start notwendig sind.

\subsection{Service}
Ein Service ist eine Komponente, die dazu gedacht ist Hintergrundprozesse zu
übernehmen. Ein Service wird von z.B. einer Activity gestarted und läuft dabei
im Hintergrund, sogar wenn die Activity nicht mehr existiert. Ein Service ist
gut dafür geeignet um z.B.
die Netzwerkkommunikation im Hintergrund zu behandeln, ohne die Applikation
selbst zu behindern.
Durch das Binden des Services an eine Applikation, wird der Service beended,
wenn die Applikation beendet wird.

\subsection{Application}
Application bietet zusätzlich zu den Activities die Möglichkeit während der
ganzen Laufzeit der Applikation eine feste Instanz zu haben, die den Zustand
bestimmter Daten beinhaltet. Es kann mit einem Singleton verglichen werden, der
den Status der Applikation beinhaltet. Durch die Methode
\textbf{\textit{Context.getApplicationContext()}}, kann auf die Application
Instanz zugegriffen werden.

\subsection{Context}
Der Context beinhaltet Informationen über die Applikationsumgebung und lässt
verschiedene Aktionen zu. Eines dieser Aktionen ist das Aufrufen von weiteren
Activities.
Eine Activity ist eine Unterklasse vom Context und wird bei der Erstellung von z.B.
einer View an diese übergeben.

\subsection{View}
Eine View representiert eine Sammlung von UI-Elementen auf einem Bildschirm. Die
Elemente werden meist über das XML-Layout erstellt und darüber referenziert.
Activities haben so die Möglichkeit eine Unterklasse der View als Instanz
aufzurufen, die das UI-Fenster representiert oder können die UI-Elemente
direkt über das XML-Layout laden.

\subsection{Handler} \label{subsec:handler}
Ein \ib{Handler} ist ein Object, das bei der Instantiierung an einen Thread
gebunden wird. Werden Nachrichten an diesen Handler geschickt, so werden diese
Nachrichten von dem an diesen Handler gekoppelten Thread ausgeführt. Der Handler
ist gut für die Kommunikation zwischen verschiedenen Thread geeignet.

\subsection{UI-Thread} \label{subsec:uithread}
Der UI Thread ist der Hauptthread, der beim Start der Applikation gestartet
wird. Dieser Thread ist für die Darstellung von UI-Elemente
verantwortlich sowie auf Benutzeraktivitäten wie Touchevents zu reagieren und
sie zu verarbeiten.

 \begin{wrapfigure}{l}{0.5\textwidth}
   \centering
   \includegraphics[width=0.45\textwidth]{chapter2/anr}
   \caption[Von Text umflossenes Bild]{ANR}
   \label{fig:anr}
  \end{wrapfigure}
  
Es ist wichtig langwierige und blockende Aufgaben wie die
Netzwerkkommunikation in ein seperaten Thread auszulagern um den UI Thread nicht
zu überlasten. Ein blockierter UI Thread kann schnell zu einer sogenannten
ANR-Meldung führen, wie im Bild \ref{fig:anr} zu sehen. Außerdem muss
bei der Verwendung von mehreren Thread darauf geachtet werden, dass die UI
Komponenten nur vom UI Thread angefasst werden. Es gibt die
Möglichkeit bei Background Threads die \textbf{\textit{runOnUiThread()}} Methode
zu verwenden, die die auszuführende Aufgabe an den UI Thread übergibt.

\subsection{AndroidManifest}
Das Android Manifest ist eine XML-Datei, die sich im Wurzelverzeichniss des
Projektes befindet. Sie beschreibt welche Rechte die Anwendung benötigt, sowie
alle Activities und Services, die während der Laufzeit gestartet werden. 
\begin{lstlisting}[caption=Android Manifest XML,label=androidManifest]
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" >
    </uses-permission>
\end{lstlisting}
Im Ausschnitt ~\ref{androidManifest} wird das Recht, den Zustand der WiFi
Verbindung zu erfragen, erteilt. Weiterhin beinhaltet das Manifest die
Information über die verwendete Android SDK Version, das Icon der Application, sowie Themes und andere relevante Daten.
\newpage

\section{AllJoyn} \label{sec:alljoyn}
\begin{wrapfigure}{l}{0.3\textwidth}
   \centering
   \includegraphics[width=0.2\textwidth]{chapter2/img-alljoyn-logo}
\end{wrapfigure} 
AllJoyn ist ein Open-Source Peer-to-Peer Rahmenwerk, das erlaubt
Verbindungen zwischen verschiedenen Geräten herzustellen. 
AllJoyn wird von Qualcomm Innovation Center Inc. entwickelt und steht unter der
Apache v.2 Licenz. Besonderer Augenmerk dieses Frameworks besteht in der
Tatsache, dass es verschiedene Betriebssysteme unterstützt und eine Vielzahl von
Programmiersprachen, darunter C$\sharp$, C++, Java sowie Objective C. Mit
AllJoyn können Anwendungen auf Peer-to-Peer Basis für
Windows,MacOS,Linux,Android und iOS entwickelt und miteinander verbunden werden.
Es bietet weiterhin die Unterstützung für
Bluetooth, Wifi und Ethernet. AllJoyn ermöglicht außerdem das Finden und die
Verbindung von Mobilen-Endgeräten im Wifi-Netz. Das AllJoyn Rahmenwerk übernimmt somit alle Aufgaben auf der
Netzwerkschicht. Zusätzlich bietet AllJoyn für jedes Betriebssystem ein SDK an,
das alle notwendigen Bibliotheken und einige Beispielanwendungen beinhaltet. 

\subsection{Bussystem} \label{subsec:bussystem}

\begin{wrapfigure}{c}{0.50\textwidth}
   \centering
   \includegraphics[width=0.50\textwidth]{chapter2/img-developer-proxy}
   \caption[Bussystem]{Bussystem \cite{alljoynbus}}
   \label{fig:Bussystem}
\end{wrapfigure} 
Das Prinzip von AllJoyn basiert auf einem Bussystem zu dem sich einzelne
Anwendung verbinden können und ist in der Abbildung ~\ref{fig:Bussystem}
nochmal visuell verdeutlicht.
Jedes dieser Anwendung muss einen \ib{BusAttachement} erstellen und
den entsprechenden EventHandler implementieren, über den die Nachrichten
von anderen Geräten behandelt werden. Es können Methoden direct auf einem
entfernten Object ausgeführt werden. Dieses Objekt wird in der Abbildung als
\ib{ProxyObject} dargestellt. Es könenn auch Nachrichten an alle Teilnehmer
gleichzeitig geschickt werden, die von einen \ib{EventHandler} behandelt
werden.
Der \ib{EventHandler} muss das entsprechende Interface implementieren, das die
Mehoden definiert, über die kommuniziert wird. Das genauere Prinzip des
\ib{BusInterface} wird im weiteren Verlauf genauer erläutert. Der \ib{Bus}
selbst ist ein sogenannter \ib{Daemon}, also ein Hintergrundprozess, der auf dem Gerät
läuft und sich um netzwerktechnischen Aufgaben kümmert. Dieser wird z.B. über
einen Aufruf in der Anwendung gestartet und bietet durch den \ib{BusAttachement}
eine Schnittstelle für Anwendungen um damit zu interagieren.

\subsection{BusAttachement}
Um mit dem Bussystem zu kommunizieren, wird ein \ib{BusAttachement}
benötigt. Dieser muss erstellt werden, wie im Codeausschnitt
~\ref{busAttachement} dargestellt.
\begin{lstlisting}[caption=BusAttachement, label=busAttachement]
bus = new BusAttachment("name",BusAttachment.RemoteMessage.Receive)
\end{lstlisting}
Der \ib{name} Parameter ist notwendig um verschiedene BusAttachements zu den
entsprechenden Anwendungen zuzuordnen, falls mehrere Anwendungen über den
selben Bus kommunizieren. AllJoyn ermöglicht es mehrere Anwendungen auf dem
selben Gerät laufen zu lassen, sodass sie untereinander kommunizieren können.
Der zweite Parameter gibt an, ob der BusAttachement
eingehende Nachrichten verwerfen oder behandeln soll. Durch den Parameter
\ib{BusAttachement.RemoteMessage.Receive} wird aufgefordert, eingehende
Nachrichten nicht zu verwerfen, sondern an die jeweiligen SignalHandler
weiterzuleiten.

\begin{wrapfigure}{r}{0.5\textwidth}
   \centering
   \includegraphics[width=0.50\textwidth]{chapter2/bus}
   \caption[Bus]{Bus}
   \label{fig:Bus}
\end{wrapfigure} 
Die Abbildung ~\ref{fig:Bus} verdeutlicht nochmal die Funktionsweise des
BusAttachements. Die mit den Buchstaben \ib{A,B,C} dargestellten Rechtecke
representieren jeweils einen BusAttachements, die zu den selben Bus
verbunden sind, der durch eine dicke durchgezogene Linie dargestellt ist.
Dieser Bus stellt intern eine logische Verbindung mit den anderen Smartphone
her, sodass jedes BusAttachement mit anderen BusAttachements kommunizieren kann.
\newpage

\subsection{Interface}
Die Kommunikation bei AllJoyn funktioniert über Interfaces, also eine konkrete
Beschreibung der Methoden über die Nachrichten verschickt werden. 
\begin{lstlisting}[caption=BusInteface Annotation,label=busInteface]
@BusInterface (name = "de.package.MyInterface")
public interface MyInterface{
@BusMethod
public void MyMethod() throws BusException;
@BusSignal
public void MySignal() throws BusException;
}
\end{lstlisting}
Im Codeausschnitt ~\ref{busInteface} ist ein \ib{BusInteface} dargestellt.
Dieses Inteface muss eine Reihe an \ib{Annotation} beinhalten. Die erste
Annotation in Zeile 1 beschreibt das Inteface, indem es den vollständigen Namen nochmal
aufführt. Die Methode \ib{MyMethod()} ist eine Methode, die auf einem
\ib{ProxyObject} von einem anderen Gerät aus ausgeführt werden kann. Die Methode
\ib{MySignal()} hingegen definiert die Methode für den \ib{SignalHandler},
welcher auf die Nachrichten reagiert, die an alle Teilnehmer gleichzeitig
geschickt werden.

\subsection{ProxyObjecte}
Ein Proxy Objekt ist ein Vertreter eines anderen Objektes, das z.B. auf einem
anderen Gerät liegt. Mithilfe von Proxy Objekten können Methoden auf diesen
entfernten Objekten ausgeführt werden. Sie implementieren das zuvor definierte
Interface, worüber dann die Kommunikation realisiert wird. Durch die Angabe
eines Intefaces, kann der BusAttachment das entsprechende ProxyObjekt
zurückliefern.

\subsection{BusObject}
Ein BusObject ist ein Objekt, das ein definierte Interface implementiert und
unter einem bestimmten Pfad abgespeichert wird. Der Pfad ist eine busweit
einzigartige Zeichenkette, die in Form eines Dateipfades dargestellt wird. Über
diesen Pfad kann mithilfe des BusAttachements das entsprechende ProxyObject
erfragt werden.
\newpage

\subsection{SignalHandler}
Ein SignalHandler ist ein Object, das die Behandlung von eingehenden
Nachrichten implementiert. Der Unterschied zwischen einem BusObject und einem
SignalHandler ist, dass beim BusObject nur die Methode auf dem
entsprechenden Object ausgeführt wird, der unter einem bestimmten Pfad
gespeichert ist. Es wird somit immer auf einem Object die Methode ausgeführt. Ein
SignalHandler reagiert auf Methodenaufrufe, die an alle
Teilnehmer geschickt werden. Dies lässt sich mit einem Broadcast vergleichen.
Falls es sich bei dem Inteface um einen SignalHandler handelt müssen die
Methoden \ib{@BusSignal} als Annotationen beinhalten
Zusätzlich muss bei der Implementierung eine weitere Annotation hinzugefügt
werden um den Nachrichtentyp explizit zu definieren.
\begin{lstlisting}[caption=BusSignalHandler Annotation,label=interfaceImpl]
@Override
@BusSignalHandler(iface = "de.packege.MyInterface", signal = "MyHandler") 
public void MyHandler() throws BusException {}
\end{lstlisting}
Im Codeausschnitt ~\ref{interfaceImpl} ist die notwendige Annotation aufgeführt.
Diese beinhaltet den vollständigen Intefacenamen und den Namen der Methode. 

\subsection{SignalEmitter}
Ein SignalEmitter ist das Objekt, das dazu verwendet wird Nachrichten an alle
Teilnehmer zu senden. Es ist im Prinzip das ProxyObject zu allen Teilnehmern.
\begin{lstlisting}[caption=SignalEmitter,label=signalEmitter]
emitter = new SignalEmitter(busObject, id, SignalEmitter.GlobalBroadcast.Off);
myInterface = (MyInterface) emitter.getInterface(MyInterface.class);
\end{lstlisting}
Der Codeausschnitt ~\ref{signalEmitter} veranschaulicht, wie ein SignalEmitter
erstellt wird. Die \ib{id} ist die SessionID, die beim
Verbinden zu einer Session mitgeteilt wird. Zusätzlich lässt sich noch
konfigurieren, ob das Signal auch über den Bus hinaus weitergeleitet wird, falls
mehrere Bussysteme gleichzeitig laufen. Als Standartkonfiguration ist die
Signalweiterleitung aus.
In Zeile 2 wird mit Angabe des Interfaces ein ProxyObject erstellt.

\subsection{Session}
Eine Session ermöglicht es mehrere Teilnehmer zu einer gemeinsamen Einheit
zusammenzufassen.  Dies erlaubt es verschiedene Anwendungsabläufe wie z.B. eine
Spielrunde von einander getrennt zu behandeln. Dazu muss ein
\ib{Channel} erstellt werden, zu dem sich alle anderen Teilnehmen verbinden
können.
Dafür benötigen alle Geräte zum einen den Namen des Channels und zum anderen die
\ib{Channelportnummer}. Über das \ib{Advertising} kann der Host den
erstellten Channelname den anderen Teilnehmern mitteilen. Um diese Mitteilungen
zu empfangen, müssen die Teilnehmer einen \ib{BusListener} implementieren, der
auf diese Nachrichten reagiert.
Das Erstellen der Session benötigt unter einigen Einstellungen, wie die
Portnummer,Transportprotokol usw, auch den \ib{SessionPortListener}, der z.B.
das Verbinden von anderen Teilnehmern behandelt. Zwei wichtige Methoden
eines SessionPortListeners sind im Codeausschnitt ~\ref{sessionPortList} aufgeführt.
\begin{lstlisting}[caption=SessionPortListener Methoden,label=sessionPortList] 
public boolean acceptSessionJoiner(short port,String joiner, SessionOpts opts)					
public void sessionJoined(short sessionPort, int id, String joiner)
\end{lstlisting}
