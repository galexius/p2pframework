\chapter{Praktisches Anwendungsbeispiel: MauMau} \label{chapter:maumau}
\section{Spielidee}
\begin{wrapfigure}{r}{0.45\textwidth}
   \centering
   \includegraphics[width=0.48\textwidth]{chapter5/maumau}
   \caption{MauMau}
   \label{fig:maumau}
\end{wrapfigure}
Das Spiel MauMau ist ein in Deutschland recht bekanntes Kartenspiel. Ziel dieses
Kartenspiels ist es, alle seine Karten loszuwerden. Zusätzlich gibt es einige
Regeln die zu beachten sind. Um dieses Spiel spielen zu können, werden
mindestens 2 Mitspieler und maximal 4 Spieler benötigt. Die maximal 4 Spieler
beruhen auf der Tatsache, dass bei dieser Version ein Skatblatt benutzt wird,
das nur 32 Karten umfasst.
Am Anfang des Spiels, wenn alle Spieler sich zum Spiel verbunden haben, bekommt
jeder 6 zufällige Karten ausgeteilt. Der Spieler, der das Spiel erstellt hat,
darf anfangen. Dabei darf pro Zug, wenn der jeweilige Spieler an der Reihe ist eine
Karte gespielt werden. Falls noch keine Karte gespielt wurde, darf jede Karte gespielt werden.
Daraufhin ist der nächste Spieler dran und muss eine den Regeln entsprechende
Karte legen. Gewonnen hat somit der Spieler, der als Erstes alle seine Karten
losgeworden ist. Das Bild ~\ref{fig:maumau} zeigt eine Bildschirmaufname von
einer Spielpartie MauMau. Dabei sieht man im oberen Bereich eine Liste mit allen
Teilnehmenden Spielern und dahin die Anzahl der Karten, die jeder dieser Spieler
besitzt. In der Mitte sieht man die zuletzt gespielte Karte, welche einen König
Karo darstellt. Die Karten ganz unten im Bild sind ein Auschnitt der Karten, die
der Spieler momentan besitzt. Die eigenen Karten sind als eine Bildergallerie
dargestellt und lassen sich somit durch eine gewöhnliche Fingebewegung scrollen.
\newline
Die Regeln in dieser implementierten Version sind folgende:
\begin{itemize}
  \item Es darf entweder die Spielfarbe oder die/den Zahl/Wert gespielt, von
  der Karte, die zuvor gespielt worden ist. Bezogen auf das Bild \ib{fig:maumau}
  darft der nächste Spieler z.B. eine Karo 8 oder einen Pick König spielen.
  \item Falls davor eine Acht gespielt wurde, muss der nächste Spieler einen Zug
  aussetzen und der übernächste Spieler ist an der Reihe. Eine Ausnahme ist,
  wenn der auszusetzende Spieler eine 8 besitzt. Dann darf der Spieler diese
  Acht legen und der nächste Spieler muss aussetzen. Die gleiche Regel ist für
  den Ass anzuwenden.
  \item Spielt ein Spieler eine Sieben, so muss der nächste Spieler 2 Karten
  ziehen, oder er hat eine Sieben und spielt sie anstatt. Falls anstatt des
  Ziehens eine Sieben gelegt wurde muss der nächste Spieler schon 4 Karten
  ziehen, bis keiner mehr eine Sieben spielen kann.
  \item Falls ein Bube gespielt wurde, darf eine Spielfarbe gewählt werden,
  die von dem nächsten Spieler gespielt werden muss.
  \item Wenn eine Karte nicht gespielt werden kann, z.B. falls keine
  passende Karte vorhanden ist, muss eine Karte gezogen werden. Falls nach dem
  Ziehen immer noch keine passende Karte vorhanden ist, muss der Zug abgegeben
  werden und der nächste Spieler ist an der Reihe.
\end{itemize}
\newpage

\section{Anforderungen}
Eine Liste mit den Anforderungen, welche zur Implementierung des Spiels
notwendig sind, sieht folgendermaßen aus:
\begin{itemize}
  \item Es werden alle Spieler aufgelistet, die zum Spiel verbunden sind.
  \item Es wird angezeigt, wie viele Karten jeder Spieler besitzt.
  \item Jeder Mitspieler sieht die zuletzt gespielte Karte.
  \item Es dürfen nur die Karten gespielt werden, die vom Regelwerk her
  erlaubt sind.
  \item Ein Karte wird gespielt, indem das das Bild der Karte berührt wird.
  \item Wenn ein Bube gespielt wird, erscheint ein Dialog, bei dem die
  Spielfarbe gewählt werden kann.
  \item Es gibt Buttons um Karten zu ziehen und um einen Zug auszusetzen, welche
  der Situation entsprechend aktiviert/deaktiviert sind. 
  \item Eine Nachricht erscheint, falls einer der Spieler gewonnen hat.
\end{itemize}

\section{Implementierung}
\subsection{Projektkonfiguration} 
Die Projektkonfiguration unterscheiden sich bis auf die Namensgebungenen nicht
von der im Kapitel \ref{subsec:projectconfig} vorgestellten Konfiguration.
Somit wird hier nicht mehr darauf eingegangen.

\subsection{MauMauApplication}
Die \ib{MauMauApplication} Klasse erbt von \ib{Application} und ist somit die
Klasse, die am Anfang gestartet wird. In der \ib{onCreate()} Methode wird der
\ib{GameManager} instanziiert und der \ib{PTPHelper} initialisiert.
Wie der \ib{PTPHelper} genau initialisiert wird sieht man im Codeausschnitt
~\ref{initHelperMauMau}.
\newpage
\begin{lstlisting}[caption=MauMau PTPHelper Initialisierung,label=initHelperMauMau] 
PTPHelper.initHelper("MauMau", this, MauMauLobbyView.class);
\end{lstlisting}
Es werden der Applicationsname, der \ib{Context}, und die \ib{MauMauLobbyView} Klasse übergeben. Der letzte
Parameter ist die konkrete Implementierung der \ib{LobbyActivity}, die nur
angibt, welche Views geöffnet werden sollen.
 Es wird außerdem noch ein \ib{DataListener} beim \ib{PTPHelper} registiert, um
 auf Nachrichten von anderen Spielen reagieren zu können. Der DataListener
 beinhaltet die gleich Implementierung, wie im Codeausschnitt \ref{dataListener}
 im Kapitel \ref{subsec:mainApplicaiton} dargestellt. Ein MessageHandler
 behandelt die empfangenen Nachrichten. Dieser führt, abhängig vom
 Nachrichtentyp, das in Form eines Integers mitgesendet wurde, die entsprechende
 Methode aus. Die 4 möglichen Methoden sind im Codeausschnitt \ref{4methods}
 aufgeführt.
 \begin{lstlisting}[caption=Empfänger Methoden MauMau,label=4methods]
 private void playerStateChanged(MessageInfoHolder message)
 private void nextTurn(MessageInfoHolder message)
 private void ownerChanged(MessageInfoHolder message) 
 private void cardPlayed(MessageInfoHolder message)  
 \end{lstlisting}
 Die Methode \ib{playerStateChanged} wird aufgerufen, wenn ein neuer Spieler der
 Session begetreten ist, oder die Session verlassen hat. Der Inhalt der
 Nachricht ist zu der ID des Spielers auch der in der Lobby vergebene Name des
 Spielers. Wenn ein Spieler seinen Zug beendet hat, teilt er dies den anderen
 Mitspielern über die Methode \ib{nextTurn} mit. Diese Nachricht beinhaltet die
 ID des Spielers, der den Zug beendet hat. Die Methode \ib{ownerChanged} teilt
 allen Spielern mit, falls eine Karte den Besitzer gewechselt hat. Dabei wird
 zum einen die ID der Karte, sowie der neue Besitzer in Form eines XML String
 übermittelt. Schließlich gibt es noch die Methode \ib{cardPlayed}. Diese
 Methode wird von dem Spieler aufgerufen, der eine Karte spielt. Der Inhalt
 der Nachricht für diese Methode ist nur die ID der Karte, die gespielt wurde.
 Bei jeder dieser Methode wird auch die ID des Spielers übergeben, von dem die
 Nachricht stamm. Jede dieser Methoden ruft die entsprechende Methode auf dem
 \ib{GameManager} auf.

\newpage
\subsection{GameManager}
Der \ib{GameManager} ist das Herzstück des Spiels und beinhaltet das Datenmodel
und alle Informationen, die für das Spiel wichtig sind. Nachdem der
GameManager instantiiert wurde, wird die \ib{reset()} Methode aufgerufen. Die
\ib{reset()} Methode setzt alle Werte auf den Anfangswert und initialisiert alle
Karten mit Werten und den entsprechenden Bitmaps. Die Bitmaps der Karten werden
aus einem Bild entnommen auf dem alle Karten sortiert abgebildet sind. Aus dem
Wert der Karte wird ein Offset ermittelt und daraus wird die Position des
Bildes dieser Karte berechnet. Der Codeausschnitt ~\ref{getBitmap} zeigt wie die
Bitmap genau erstellt werden.
\begin{lstlisting}[caption=Bitmaps den Karten zuweisen,label=getBitmap]
public Bitmap getBitmap(Context context,Card card){
	if(allCards == null){
		allCards = BitmapFactory.decodeResource(context.getResources(),
             R.drawable.cards);
	}			
	int cardWidth = allCards.getWidth()/13;
	int cardHeight = allCards.getHeight()/5;
	int value = card.value;
	if(value == 14) value = 1; //Ace is positioned at the beginning of the bitmap
	Bitmap cardBitmap = Bitmap.createBitmap(allCards,(value-1)*(cardWidth), (card.suit)*(cardHeight),cardWidth, cardHeight);
	return cardBitmap;			
}
\end{lstlisting}
Der \ib{GameManager} besitzt einen sogenannten \ib{RuleEnforcer}, der dafür
zuständig ist situationsbedingt verschiedene Regeln anzuwenden. Der
\ib{RuleEnforcer} besitzt zwei Listen von \ib{Rules}, wobei jedes dieser
\ib{Rules} eine Methode \ib{ boolean isAllowed(Card)} implementiert. Eine Liste
beinhaltet inklusive Regeln, also Regeln, die alle erfühlt sein müssen. Die
zweite Liste beinhaltet die exklusiven Regeln, bei denen mindestens eine Regeln
erfühlt sein muss. Ein Beispiel dafür ist die Regel, dass ein Spieler am Zug
ist.
Diese Regel muss immer gelten, wenn ein Spieler eine Karte spielen will, somit
geht diese Regel in die inklusive Liste. Die Regeln, dass eine Spielfarbe oder ein
bestimmter Wert gespielt werden muss, gehören in die exklusive Liste, da nur
eine dieser Regeln erfühlt sein muss um eine Karte spielen zu können. 
Diese Liste wird am Ende jedes Zuges aktuallisiert, wie im Codeausschnitt
~\ref{cardPlayedEvent} aus der Methode \ib{NextTurn} zu sehen ist.
\newpage
\begin{lstlisting}[caption=Aktuallisierung der Regeln,label=cardPlayedEvent]
CardPlayedEvent cardPlayedEvent = new CardPlayedEvent(playedCard, playCardRuleEnforcer,this);
cardPlayedEvent.updateRuleEnforcer();
\end{lstlisting}
Der \ib{GameManager} besitzt 5 Methoden, die dazu bestimmt sind mit anderen
Spieler zu kommunizieren. Diese Methoden werden entweder lokal von der \ib{View}
ausgeführt, oder von der \ib{MauMauApplication}, wenn der Aufruf von den anderen
Spielern kommt. Die Methoden sind im Codeausschnitt
~\ref{gmInteface} aufgelistet.
\begin{lstlisting}[caption=Methoden des GameManagerInteface,label=gmInteface]
	public void ChangeOwner(int cardId, String uniqueUserID);
	public void PlayCard(int cardId, String uniqueUserID);	
	public void NextTurn(String uniqueUserID,int specialCase);	
	public void HiIAm(String uniqueID,String playerName);	
	public void ByeIWas(String uniqueID,String playerName);
\end{lstlisting}
Die Methode \ib{HiIAm} wird von jeden Mitspieler aufgerufen, der sich zu einem
Spiel verbindet, sodass alle diesen Spieler kennen und in die Mitspielerliste
einfügen können.
Die Methode \ib{ByIWas} hingegen wird aufgerufen um mitzuteilen, wenn ein
Mitspieler die Runde verlässt und somit aus der Mitspielerliste entfernt werden
kann.
\ib{NextTurn} wird von dem Spieler aufgerufen, der gerade am Zug ist und den
Spielzug beendet hat. Ein Parameter ist immer die \ib{uniqueID}, sodass immer
bei der Abarbeitung der Methoden klar ist, von wem der Methodenaufruf stamm.
Die \ib{NextTurn} Methode hat noch den zweiten Parameter
\ib{specialCase}, der bestimmte Situationen kennzeichnet. Es wird z.B. nur
die letzte Karte gespeichert, die gespielt wurde. Somit kann nicht mehr
nachvollzogen werden, ob 2 oder 3 Siebenen aufeinander gespielt wurden und der
Spieler z.B. 6 Karten anstatt nur 2 ziehen soll. Diese Situation wird über diesen
Parameter übergeben. Wenn \ib{specialCase=3} ist, bedeutet es, dass die Sieben 3
mal aufeinander gespielt wurde.
Dann gibt es noch die \ib{ChangeOwner} Methode, die dafür zuständig ist den
Kartenstatus synchron zu halten. D.h. wenn jemand eine Karte zieht, muss jeder
GameManager davon erfahren, sodass zwei Spieler nicht die selbe Karten ziehen
können.
Schließlich gibt es noch die \ib{PlayCard} Methode, die allen Mitspielern
mitteilt, welche Karte gespielt wurde und auf dem Bildschirm angezeigt werden
kann.

\subsection{GameActivity}
Die \ib{GameActivity} ist zum Einen für die Behandlung von Benutzereingaben
zuständig und zum Anderen für die graphische Darstellung des Spiels. Die
\ib{onCreate()} Method beinhaltet die Initialisierung der Buttons und anderen UI
Elementen wie z.B. der \ib{Gallery}. Die \ib{Gallery} ist aus dem Android SDK
und ist dafür vorgesehen mehrere Bilder darzustellen und stellt Funktionen
bereit wie das Scrollen und Auswählen von diesen. Die Gallery ist jedoch seit
de Android API 16 Deprecated. Als Ersatz kann auch die Klasse
\ib{HorizontalScrollView} verwendet werden. Um die \ib{Gallery} mit Bildern zu
füllen, wird ein \ib{BaseAdapter} benötigt, das im Prinzip das Datenmodel
darstellt.
Damit die \ib{Gallery} den aktuellen Stand der Karten anzeigt, wird der
\ib{BaseAdapter} upgedatet, das wiederum die Gallery benachrichtigt, die Karten
neu anzuzeigen. Dann gibt es den \ib{OnItemClickListener}, der für die
\ib{Gallery} implementiert wird. Dieser Listener implementiert die Aktionen, die
ausgeführt werden sollen, falls eine Karte berührt wird. Ein Auschnitt aus der
\ib{OnItemClick} Methode zeigt der Codeausschnitt ~\ref{onItemClick}.
\begin{lstlisting}[caption=Karte spielen,label=onItemClick]
 if(gameManager.canPlayCard(card)){
   if(card.value == 11){	
	 cardToPlay = card;
	 showWishSuitWindow(card); 
   }else{					   
	 playCard(card);
   }					
 } 
\end{lstlisting}

Hierbei wird zuerst der \ib{gameManager} gefragt, ob die Karte
gespielt werden kann, indem es mit dem \ib{RuleEnforcer} geprüft wird.\newline
\begin{wrapfigure}{r}{0.5\textwidth}
   \centering
   \includegraphics[width=0.48\textwidth]{chapter5/wishsuit}
   \caption{Spielfarbe wünschen}
   \label{fig:wishsuit}
\end{wrapfigure}
Danach wird geprüft, ob es sich bei der Karte um einen Buben handelt und ein
Fenster angezeigt werden soll, das für das Auswählen einer Wunschfarbe
vorgesehen ist. Dieses Fenster ist auf dem Bild ~\ref{fig:wishsuit} zu sehen.
Andernfalls wird die Karte gespielt, in dem die Karten-ID dem
\ib{GameManager} mitgeteilt wird.
Die \ib{GameActivity} implementiert auch den \ib{GameManagerObserver} Inteface,
sodass es auch eine \ib{update(int)} Methode gibt. Dadurch kriegt die
\ib{GameActivity} z.B. mit, ob eine neue Karte gespielt wurde oder sich ein
neuer Spieler verbunden hat und die UI neu gezeichnet werden muss. 
Es gibt bei Android auch die Möglichkeit auf den Zurückbutton zu drücken,was
dafür sorgt,dass man die vorheriege View aufgerufen wird. Dies wird
dem \ib{GameManager} und dem \ib{PTPService} mitgeteilt, da durch das drücken
des Zurückbuttons das laufende Spiel verlassen wird. Der Codeausschnitt
~\ref{backButton} zeigt die Behandlung dieses Zurückbuttons.

\begin{lstlisting}[caption=Behandlung des Zurückbutton,label=backButton]
@Override
public void onBackPressed(){
  super.onBackPressed();
  gameManager.reset();
  PTPHelper.getInstance().leaveSession();
  PTPHelper.getInstance().disconnect();
  PTPHelper.getInstance().connectAndStartDiscover();
}
\end{lstlisting}
Dabei wird die \ib{onBackPressed()} Methode von der \ib{Activity} überschrieben.
Weiterhin wird der \ib{gameManager} zurückgesetzt, sodass alles wieder mit
Anfangswerten initialisiert ist und ein neues Spiel gestartet werden kann. Zum
Schluss wird dem \ib{PTPHelper} mitgeteilt die laufende Session zu schliessen und
eine neue Verbindung aufzubauen, sodass der Anfangszustand erreicht wird, da
durch die Zurücktaste die Lobby aufgerufen wird.
