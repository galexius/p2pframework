\chapter{Praktisches Anwendungsbeispiel: Graphenspiel}

\section{Spielidee}
Das Prinzip des Graphenspiels basiert im darauf, dass die Spieler einen
Graphen sehen, bei dem sich die Kanten anfangs überschneiden. Ziel des
Spieles ist es die Knoten des Graphen so zu bewegen, dass sich keine Kante mehr
überschneidet.
\begin{wrapfigure}{r}{0.45\textwidth}
   \centering
   \includegraphics[width=0.4\textwidth]{chapter4/graphscreen}
   \caption{Graphspiel}
   \label{fig:graphgame}
\end{wrapfigure}
Die Schwierigkeit beim Spiel ist, dass sich alle anderen Knoten
mitbewegen. Lediglich die Knoten, die von den anderen Spielern gehalten bzw.
bewegt werden, werden nicht mitbewegt. Durch diese Tatsache, lässt sich das
Spiel nur mit mehreren Spielern gewinnen.
Es handelt sich hierbei um ein sogenanntes kooperatives Mehrspielerspiel. Auf
dem Bild ~\ref{fig:graphgame} ist zu erkennen, dass der Knoten mit der Nummer 6
rot markiert ist. Somit kann der Spieler diesen Knoten nicht bewegen. Alle
anderen Knoten, die blau markiert sind, können vom Spieler jedoch bewegt werden.
Das Puzzel lässt sich einfacher lösen, wenn mehr Leute mitspielen. Dies bringt
einen weiteren sozialen Aspekt, das das Spielen mit mehr Leuten fördert.
Die Spieler können sich wärend des Spielens zu dem Spiel verbinden, d.h. selbst
wenn ein Spiel schon im Gange ist, kann ein weiterer Spieler beitreten und
mithelfen. Die Spieler können auch jederzeit das Spiel verlassen, ohne das
Beenden des Spiels zu verursachen.
Es ist jedoch zu beachten, dass immernoch mindestens 2 Spieler benötigt werden,
um das Rätsel lösen zu können.

\section{Implementierung}
\subsection{Projektkonfiguration} \label{subsec:projectconfig}
Für die Entwicklung des Spieles ist das Eclipse ADT verwendet worden, sodass die
Beschreibung der Projektkonfiguration sich auf Eclipse beruhen. Als Erstes wird
ein \ib{Android Application Project} erstellt. Dabei werden die
Applicationname, Packagename und Projektname entsprechend angegeben. Eine
vorimplementierte Activity wird entfernt, da eine eine Activity hierfür
implementiert wird.
Als das Target SDK wird \ib{Android 4.2 Jelly Bean} und als Mininum wird
\ib{Android 2.3} verwendet, da AllJoyn mindestens die Android Version 2.3 benötigt. 
\begin{wrapfigure}{r}{0.5\textwidth}
   \centering
   \includegraphics[width=0.48\textwidth]{chapter4/includelibrary}
   \caption{Bibliothekreferenz}
   \label{fig:lib}
\end{wrapfigure}
Als nächstes ist es notwendig das \ib{PTPLibrary} Projekt
als Bibliothek im Spielprojekt zu referenzieren, wie im Bild ~\ref{fig:lib}
zu sehen. Durch einen Rechtsklickt auf das Projekt erscheint ein Kontextmenu,
bei den Eigenschaften ausgewählt werden.
Unter den Reiter \ib{Android} ist die Einstellung für Bibliotheken. Dort muss
die \ib{PTPLibrary} als Bibliothek angeben werden. Android erlaubt es
nicht \ib{Libraries} als gewöhnliche Jar Dateien zu packen, daher muss die
Bibliothek als Android Projekt referenziert werden.\cite{androidLib}

\subsection{MainApplication} \label{subsec:mainApplicaiton}
Die \ib{MainApplication} Klasse wird beim Ausführen der Anwendung als erstes
ausgeführt und ist für die Initialisierung von für das Spiel wichtigen Objekten
verantwortlich. Am Anfang wird die \ib{onCreate()} Methode aufgerufen. Im
Codeausschnitt ~\ref{onCreateMain} ist der Inhalt der Methode zu sehen.
\begin{lstlisting}[caption=onCreate Methode,label=onCreateMain]
super.onCreate();
graph = new Graph();
graph.addObserver(this);  
graph.setupPoints();    
PTPHelper.initHelper("GraphGame",this, GraphLobbyActivity.class);
\end{lstlisting}
Dabei wird als erstes das Graphobjekt erstellt und konfiguriert, das das
Datenmodel des Spieles representiert. Als zweites wird dann der \ib{PTPService}
initialisiert. Dabei wird die \ib{GraphLobbyActivity} Klasse übergebe, die die
\ib{LobbyActivity} implementiert, übergeben. Die GraphLobbyActivity definiert
nur die \ib{Activity}, die geöffnet werden soll, wenn eine Spielsession erstellt
wurde, oder zu einer Spielsession verbunden wurde. Dann wird noch ein
\ib{DataListener} beim \ib{PTPHelper} registiert, um auf Nachrichten von anderen Spielen reagieren zu können. Der Codeausschnitt \ref{dataListener} zeigt den Inhalt des \ib{DataListeners}.

 \begin{lstlisting}[caption=DataListener,label=dataListener]
PTPHelper.getInstance().addDataListener(new DataListener() {			
			@Override
			public void dataSentToAllPeers(String peersID, int messageType, String[] data) {
				MessageInfoHolder infoHolder = new MessageInfoHolder();
				infoHolder.data = data;
				infoHolder.sentBy = peersID;
				sendMessage(messageType, infoHolder);
			}
		});
\end{lstlisting}
Der DataListener beinhaltet eine Methode, die die ID des Senders als String, den
Nachrichtentyp als Integer, und die Daten als ein String Array übergibt. Diese Informationen
werden als ein Object von Typ \ib{MessageInfoHolder} zusammengefasst, um es an
den \ib{MessageHandler} als \ib{Message} senden zu können.
Der MessageHandler läuft auf dem \ib{UIThread} und verhindert Threadkollisionen,
da die Methode des DataListeners vom Thread des Hintergrundservices aufgerufen
wird. Der MessageHandler entscheidet anhand des Nachrichtentyps die Methode, die
aufgerufen werden soll, und ruft diese mit den Nachrichteninhalt auf. Im
Codeausschnitt \ref{receiveMethods} sind die 2 Methoden aufgeführt, die beim
Empfangen von Nachrichten verwendet werden.
\begin{lstlisting}[caption=Empfänger Methoden,label=receiveMethods] 
private void nodeOwnerChanged(MessageInfoHolder obj) {
	Node node = graph.getNodeFromXML(obj.data[0]);
    graph.ChangeOwnerOfNode(node.getId(),node.getOwner(), obj.sentBy);
}

private void nodePositionChanged(MessageInfoHolder obj) {
	Node node = graph.getNodeFromXML(obj.data[0]);
    graph.MoveNode(node.getId(), node.getX(), node.getY(), obj.sentBy);	
}
\end{lstlisting}
Die Daten werden als ein XML String versendet und werden mithilfe einer
Bibliothek namens \ib{PeerParser} \cite{peerParser} in ein entsprechendes Object
umgewandelt.
Die Attribute des Objectes werden dazu verwenden Methoden auf dem Graph auszuführen.

\subsection{Graph}
Der \ib{Graph} representiert das Datenmodel des Spiels und beinhaltet somit alle
Spielrelevanten Daten. Die Beschreibung des Graphen wird durch einfache Kanten
und Knoten gespeichert, die in einer Liste abgelegt werden. Jede Kante
verweist auf zwei Knoten und jeder Knoten besitzt eine \ib{ID} und eine
Positionn als X- und Y-Koordinate. Die im Codeausschnitt
~\ref{graphInterface} dargestellten Methoden, sind die 2 Methoden, die für die
Kommunikation mit anderen Spielern wichtig sind.
\begin{lstlisting}[caption=GraphInteface, label=graphInterface]
public void MoveNode(int id,double x,double y, String uniqueName);
public void ChangeOwnerOfNode(int id,String owner, String uniqueID);	 
\end{lstlisting}
Die Methode \ib{MoveNode} wird aufgerufen, wenn ein Spieler einen Knoten
verschoben hat. Die Methode \ib{ChangeOwnerOfNode} wird aufgerufen, wenn jemand
einen Knoten berührt oder loslässt, sodass der Knoten einem Besitzer zugewiesen
werden kann. Der letzte Parameter \ib{uniqueID} ist die ID von den Spieler, der
diese Methode aufruft. Mithilfe dieses Parameters wird innerhalb der Methode
entschieden, ob der Methodenaufruf lokal stattgefunden hat, oder von einem
anderen Spieler stamm. Falls der Methodenaufruf lokal stattgefunden hat, werden
die Daten über die Änderung in ein XML String gepackt und an die anderen Spieler
verschickt. Der Codeausschnitt \ref{sendChangeOwner} zeigt einen Ausschnitt aus
der Methode \ib{ChangeOwnerOfNode} 
\begin{lstlisting}[caption=Sende Änderung des
Besitzers,label=sendChangeOwner] if(uniqueID.equals(PTPHelper.getInstance().getUniqueID())){
	Node nodeToChange = new Node();
	nodeToChange.setid(id);
	nodeToChange.setOwner(owner);
	
	XMLIdMap map=new XMLIdMap();
	map.withCreator(new NodeCreator());	
	XMLEntity entity = map.encode(nodeToChange);
	PTPHelper.getInstance().sendDataToAllPeers(NODE_OWNERSHIP_CHANGED, new String[]{entity.toString()});
	return;
}
\end{lstlisting}
Dabei wird wieder die Bibliothek \ib{PeerParser} verwenden um aus dem Node
Object einen XML String zu erstellen. Dieser wird im Anschluss, mit Angabe des
Nachrichtentyps \ib{NODE\_OWNERSHIP\_CHANGED}, über den PTPhelper an die anderen
Spieler verschickt.

\subsection{DrawView}
Die \ib{DrawView} ist für die grafische Darstellung und die Benutzereingaben
zuständig. Diese Klasse ist die Unterklasse von \ib{View} und implementiert
zusätzlich den \ib{OnTouchListener} und den \ib{GraphObserver}. Die \ib{View}
ist eine Android Klasse und beinhaltet als wichtigste Methode \ib{onDraw(Canvas)},
die dafür zuständig ist die Kanten und Knoten auf dem \ib{Canvas} zu
zeichnen. Außerdem wird in dieser Methode geprüft, ob der Graph gelöst ist und
eine Meldung dass das Spiel gewonnen worden ist, erscheinen soll.
Die Methode \ib{isGraphFinished()} überprüft, durch die Benutzung eines
Algorithmus \cite{algorithm}, ob sich noch Kanten überschneiden.
Durch die Implementierung des \ib{OnTouchListeners} wird die Methode
\ib{onTouch(View, MotionEvent)} benutzt, die sich um die
Benutzeraktivitäten kümmert. Dabei wird z.B.
bei der ersten Berührung geprüft ob der Knoten noch keinen Besitzer hat, und daraufhin
der neue Besitzer zugewiesen. Die Abfrage ob es sich um die erste Berührung
handelt, wird im Codeausschnitt ~\ref{actionDown} gezeigt. 
\begin{lstlisting}[caption=Erste Berührung,label=actionDown]
if(event.getAction() == MotionEvent.ACTION_DOWN)
\end{lstlisting}
Weiterhin gibt es noch den \ib{ACTION\_UP} Bewegungstatus, welches das lösen des
Fingers bedeutet. In diesem Fall wird der Knoten, falls einer diesem Spieler
zugewiesen war, wieder freigegeben. Und schließlich gibt es noch den Fall, dass
keiner dieser Fälle gegeben ist und dies bedeutet nur das der Finger bewegt
wird. Hierbei wird die letzte Position des Knoten mit der momentanen Position
des Fingers berechnet und die Differenz zum Knoten hinzuaddiert. Der
Knoten wird auf die Position des Fingers bewegt. In jedem dieser Fälle wird die
Änderung an die anderen Spieler mitgeteilt.
Dann gibt es noch die Methode \ib{update(int)}des \ib{GraphObservers}, die
auf die Nachricht hört, dass der Graph neu gezeichnet werden soll. Der
Codeausschnitt ~\ref{updateGraph} zeigt den Inhalt dieser Methode.
\newpage
\begin{lstlisting}[caption=Graphen neu zeichnen,label=updateGraph]
@Override
public void update(int args) {
	if(Graph.GRAPH_CHANGED == args)
		postInvalidate();	
}
\end{lstlisting}
Die \ib{postInvalidate()} Methode gehört zu der View Klasse und muss aufgerufen
werden, um dem UI Thread mitzuteilen, dass die View nicht aktuell ist. Diese
Methode muss aufgerufen werden, wenn der Aufrufen nicht vom UI Thread kommt.
Falls der Aufruf innerhalb des UI Threads befindet, wie z.B.
bei der Abarbeitung der Berührungsaktivität reicht es die Methode \ib{invalidate()} aufzurufen.
