package com.example.firstapp;


import org.alljoyn.bus.BusAttachment;
import org.alljoyn.bus.BusException;
import org.alljoyn.bus.BusListener;
import org.alljoyn.bus.BusObject;
import org.alljoyn.bus.Mutable;
import org.alljoyn.bus.SessionListener;
import org.alljoyn.bus.SessionOpts;
import org.alljoyn.bus.SessionPortListener;
import org.alljoyn.bus.SignalEmitter;
import org.alljoyn.bus.Status;
import org.alljoyn.bus.annotation.BusSignal;

import android.annotation.SuppressLint;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.util.Log;


@SuppressLint("HandlerLeak")
public abstract class MainService implements Observer {

    private static final int EXIT = 1;
    private static final int CONNECT = 2;
    private static final int DISCONNECT = 3;
    private static final int START_DISCOVERY = 4;
    private static final int REQUEST_NAME = 6;
    private static final int RELEASE_NAME = 7;
    private static final int BIND_SESSION = 8;
    private static final int UNBIND_SESSION = 9;
    private static final int ADVERTISE = 10;
    private static final int CANCEL_ADVERTISE = 11;
    private static final int JOIN_SESSION = 12;
    private static final int LEAVE_SESSION = 13;
    private static final int SEND_MESSAGES = 14;
	
	private final class BackgroundHandler extends Handler {
        @SuppressLint("HandlerLeak")
		public BackgroundHandler(Looper looper) {
            super(looper);
        }
        
        /**
         * Exit the background handler thread.  This will be the last message
         * executed by an instance of the handler.
         */
        public void exit() {
            Log.i(TAG, "mBackgroundHandler.exit()");
        	Message msg = mBackgroundHandler.obtainMessage(EXIT);
            mBackgroundHandler.sendMessage(msg);
        }
        
        /**
         * Connect the application to the Alljoyn bus attachment.  We expect
         * this method to be called in the context of the main Service thread.
         * All this method does is to dispatch a corresponding method in the
         * context of the service worker thread.
         */
        public void connect() {
            Log.i(TAG, "mBackgroundHandler.connect()");
        	Message msg = mBackgroundHandler.obtainMessage(CONNECT);
            mBackgroundHandler.sendMessage(msg);
        }
        
        /**
         * Disonnect the application from the Alljoyn bus attachment.  We
         * expect this method to be called in the context of the main Service
         * thread.  All this method does is to dispatch a corresponding method
         * in the context of the service worker thread.
         */
        public void disconnect() {
            Log.i(TAG, "mBackgroundHandler.disconnect()");
        	Message msg = mBackgroundHandler.obtainMessage(DISCONNECT);
            mBackgroundHandler.sendMessage(msg);
        }

        /**
         * Start discovering remote instances of the application.  We expect
         * this method to be called in the context of the main Service thread.
         * All this method does is to dispatch a corresponding method in the
         * context of the service worker thread.
         */
        public void startDiscovery() {
            Log.i(TAG, "mBackgroundHandler.startDiscovery()");
        	Message msg = mBackgroundHandler.obtainMessage(START_DISCOVERY);
        	mBackgroundHandler.sendMessage(msg);
        }

        public void requestName() {
            Log.i(TAG, "mBackgroundHandler.requestName()");
        	Message msg = mBackgroundHandler.obtainMessage(REQUEST_NAME);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void releaseName() {
            Log.i(TAG, "mBackgroundHandler.releaseName()");
        	Message msg = mBackgroundHandler.obtainMessage(RELEASE_NAME);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void bindSession() {
            Log.i(TAG, "mBackgroundHandler.bindSession()");
        	Message msg = mBackgroundHandler.obtainMessage(BIND_SESSION);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void unbindSession() {
            Log.i(TAG, "mBackgroundHandler.unbindSession()");
        	Message msg = mBackgroundHandler.obtainMessage(UNBIND_SESSION);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void advertise() {
            Log.i(TAG, "mBackgroundHandler.advertise()");
        	Message msg = mBackgroundHandler.obtainMessage(ADVERTISE);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void cancelAdvertise() {
            Log.i(TAG, "mBackgroundHandler.cancelAdvertise()");
        	Message msg = mBackgroundHandler.obtainMessage(CANCEL_ADVERTISE);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void joinSession() {
            Log.i(TAG, "mBackgroundHandler.joinSession()");
        	Message msg = mBackgroundHandler.obtainMessage(JOIN_SESSION);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void leaveSession() {
            Log.i(TAG, "mBackgroundHandler.leaveSession()");
        	Message msg = mBackgroundHandler.obtainMessage(LEAVE_SESSION);
        	mBackgroundHandler.sendMessage(msg);
        }
        
        public void sendMessages() {
            Log.i(TAG, "mBackgroundHandler.sendMessages()");
        	Message msg = mBackgroundHandler.obtainMessage(SEND_MESSAGES);
        	mBackgroundHandler.sendMessage(msg);
        }
                 
        /**
         * The message handler for the worker thread that handles background
         * tasks for the AllJoyn bus.
         */
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case CONNECT:
	            doConnect();
            	break;
	        case DISCONNECT:
		        doDisconnect();
		    	break;
	        case REQUEST_NAME:
		        doRequestName();
		    	break;
	        case RELEASE_NAME:
		        doReleaseName();
		    	break;		
	        case BIND_SESSION:
		        doBindSession();
		    	break;
	        case UNBIND_SESSION:
		        doUnbindSession();
		        break;
	        case JOIN_SESSION:
		        doJoinSession();
		    	break;
	        case LEAVE_SESSION:
		        doLeaveSession();
		        break;
	        case SEND_MESSAGES:
		        doSendMessages();
		        break;
	        case EXIT:
                getLooper().quit();
                break;
		    default:
		    	break;
            }
        }
    }
	
	private Handler mHandler = new Handler() {
        public void handleMessage(Message msg) {
            switch (msg.what) {
	            case HANDLE_APPLICATION_QUIT_EVENT:
	            {
	                Log.i(TAG, "mHandler.handleMessage(): APPLICATION_QUIT_EVENT");
	                mBackgroundHandler.leaveSession();
	                mBackgroundHandler.cancelAdvertise();
	                mBackgroundHandler.unbindSession();
	                mBackgroundHandler.releaseName();
	                mBackgroundHandler.exit();
	                destroy();
	            }
	            break;            
            case HANDLE_USE_JOIN_CHANNEL_EVENT:
	            {
	                Log.i(TAG, "mHandler.handleMessage(): USE_JOIN_CHANNEL_EVENT");
	                mBackgroundHandler.joinSession();
	            }
	            break;
	        case HANDLE_USE_LEAVE_CHANNEL_EVENT:
	            {
	                Log.i(TAG, "mHandler.handleMessage(): USE_LEAVE_CHANNEL_EVENT");
	                mBackgroundHandler.leaveSession();
	            }
	            break;
	        case HANDLE_HOST_INIT_CHANNEL_EVENT:
	            {
	                Log.i(TAG, "mHandler.handleMessage(): HOST_INIT_CHANNEL_EVENT");
	            }
	            break;	            
	        case HANDLE_HOST_START_CHANNEL_EVENT:
	            {
	                Log.i(TAG, "mHandler.handleMessage(): HOST_START_CHANNEL_EVENT");
	                mBackgroundHandler.requestName();
	                mBackgroundHandler.bindSession();
	                mBackgroundHandler.advertise();
	            }
	            break;
	        case HANDLE_HOST_STOP_CHANNEL_EVENT:
	            {
	                Log.i(TAG, "mHandler.handleMessage(): HOST_STOP_CHANNEL_EVENT");
	                mBackgroundHandler.cancelAdvertise();
	                mBackgroundHandler.unbindSession();
	                mBackgroundHandler.releaseName();
	            }
	            break;
	        case HANDLE_OUTBOUND_CHANGED_EVENT:
	            {
	                Log.i(TAG, "mHandler.handleMessage(): OUTBOUND_CHANGED_EVENT");
	                mBackgroundHandler.sendMessages();
	            }
	            break;
            default:
                break;
            }
        }


    };

    
    /**
     * Value for the HANDLE_APPLICATION_QUIT_EVENT case observer notification handler. 
     */
    private static final int HANDLE_APPLICATION_QUIT_EVENT = 0;
    
    /**
     * Value for the HANDLE_USE_JOIN_CHANNEL_EVENT case observer notification handler. 
     */
    private static final int HANDLE_USE_JOIN_CHANNEL_EVENT = 1;
    
    /**
     * Value for the HANDLE_USE_LEAVE_CHANNEL_EVENT case observer notification handler. 
     */
    private static final int HANDLE_USE_LEAVE_CHANNEL_EVENT = 2;
    
    /**
     * Value for the HANDLE_HOST_INIT_CHANNEL_EVENT case observer notification handler. 
     */
    private static final int HANDLE_HOST_INIT_CHANNEL_EVENT = 3;
    
    /**
     * Value for the HANDLE_HOST_START_CHANNEL_EVENT case observer notification handler. 
     */
    private static final int HANDLE_HOST_START_CHANNEL_EVENT = 4;
    
    /**
     * Value for the HANDLE_HOST_STOP_CHANNEL_EVENT case observer notification handler. 
     */
    private static final int HANDLE_HOST_STOP_CHANNEL_EVENT = 5;
    
    /**
     * Value for the HANDLE_OUTBOUND_CHANGED_EVENT case observer notification handler. 
     */
    private static final int HANDLE_OUTBOUND_CHANGED_EVENT = 6;
    

	private BusAttachment mBus;
  
	public synchronized void update(Observable o, Object arg) {
        Log.i(TAG, "update(" + arg + ")");
        String qualifier = (String)arg;
        
        if (qualifier.equals(MainApplication.APPLICATION_QUIT_EVENT)) {
            Message message = mHandler.obtainMessage(HANDLE_APPLICATION_QUIT_EVENT);
            mHandler.sendMessage(message);
        }
        
        if (qualifier.equals(MainApplication.USE_JOIN_CHANNEL_EVENT)) {
            Message message = mHandler.obtainMessage(HANDLE_USE_JOIN_CHANNEL_EVENT);
            mHandler.sendMessage(message);
        }
        
        if (qualifier.equals(MainApplication.USE_LEAVE_CHANNEL_EVENT)) {
            Message message = mHandler.obtainMessage(HANDLE_USE_LEAVE_CHANNEL_EVENT);
            mHandler.sendMessage(message);
        }
        
        if (qualifier.equals(MainApplication.HOST_INIT_CHANNEL_EVENT)) {
            Message message = mHandler.obtainMessage(HANDLE_HOST_INIT_CHANNEL_EVENT);
            mHandler.sendMessage(message);
        }
        
        if (qualifier.equals(MainApplication.HOST_START_CHANNEL_EVENT)) {
            Message message = mHandler.obtainMessage(HANDLE_HOST_START_CHANNEL_EVENT);
            mHandler.sendMessage(message);
        }
        
        if (qualifier.equals(MainApplication.HOST_STOP_CHANNEL_EVENT)) {
            Message message = mHandler.obtainMessage(HANDLE_HOST_STOP_CHANNEL_EVENT);
            mHandler.sendMessage(message);
        }
        
        if (qualifier.equals(MainApplication.OUTBOUND_CHANGED_EVENT)) {
            Message message = mHandler.obtainMessage(HANDLE_OUTBOUND_CHANGED_EVENT);
            mHandler.sendMessage(message);
        }
    }
	
public static final short CONTACT_PORT = 27;
    
    /**
     * The object path used to identify the service "location" in the bus
     * attachment.
     */
    public static final String OBJECT_PATH = "/prototype";
    
    /**
     * The ChatBusListener is a class that listens to the AllJoyn bus for
     * notifications corresponding to the existence of events happening out on
     * the bus.  We provide one implementation of our listener to the bus
     * attachment during the connect(). 
     */
    private class PrototypeBusListener extends BusListener {
   		/**
		 * This method is called when AllJoyn discovers a remote attachment
		 * that is hosting an chat channel.  We expect that since we only
		 * do a findAdvertisedName looking for instances of the chat
		 * well-known name prefix we will only find names that we know to
		 * be interesting.  When we find a remote application that is
		 * hosting a channel, we add its channel name it to the list of
		 * available channels selectable by the user.
         *
         * In the class documentation for the BusListener note that it is a
         * requirement for this method to be multithread safe.  This is
         * accomplished by the use of a monitor on the ChatApplication as
         * exemplified by the synchronized attribute of the addFoundChannel
         * method there.
		 */
		public void foundAdvertisedName(String name, short transport, String namePrefix) {
            Log.i(TAG, "mBusListener.foundAdvertisedName(" + name + ")");
		}
		
   		/**
		 * This method is called when AllJoyn decides that a remote bus
		 * attachment that is hosting an chat channel is no longer available.
		 * When we lose a remote application that is hosting a channel, we
		 * remote its name from the list of available channels selectable
		 * by the user.  
         *
         * In the class documentation for the BusListener note that it is a
         * requirement for this method to be multithread safe.  This is
         * accomplished by the use of a monitor on the ChatApplication as
         * exemplified by the synchronized attribute of the removeFoundChannel
         * method there.
		 */
		public void lostAdvertisedName(String name, short transport, String namePrefix) {
            Log.i(TAG, "mBusListener.lostAdvertisedName(" + name + ")");
		}
    }
    
    /**
     * An instance of an AllJoyn bus listener that knows what to do with
     * foundAdvertisedName and lostAdvertisedName notifications.  Although
     * we often use the anonymous class idiom when talking to AllJoyn, the
     * bus listener works slightly differently and it is better to use an
     * explicitly declared class in this case.
     */
    private PrototypeBusListener mBusListener = new PrototypeBusListener();
	
    class PrototypeService implements MyInterface, BusObject {

		@Override
		@BusSignal
		public String MyMethod(double x, double y) throws BusException {
			Log.i(TAG, "message received: "+ x + " , " + y);
			return null;
		}
   
    }
    
    
    PrototypeService mService = new PrototypeService();
    
    protected String getWellKnownName(){
//    	MainApplication application = (MainApplication) getApplication();
//    	String wellKnownName = MainApplication.PACKAGE_NAME + ".prototype." + application.getHostChannelName();
//    	return wellKnownName;
    	return "";
    }
    
	 private void doConnect() {
	        Log.i(TAG, "doConnect()");
	        //org.alljoyn.bus.alljoyn.DaemonInit.PrepareDaemon(getApplicationContext());
	        assert(mBusAttachmentState == BusAttachmentState.DISCONNECTED);
	    	mBus.useOSLogging(true);
	    	mBus.setDebugLevel("ALLJOYN_JAVA", 7);
	    	mBus.registerBusListener(mBusListener);
	    	
	        /* 
	         * To make a service available to other AllJoyn peers, first
	         * register a BusObject with the BusAttachment at a specific
	         * object path.  Our service is implemented by the ChatService
	         * BusObject found at the "/chatService" object path.
	         */
	        Status status = mBus.registerBusObject(mService, OBJECT_PATH);
	        if (Status.OK != status) {
	    		Log.e(TAG, "Cannot register");
	    		return;
	        }
	    	
	    	status = mBus.connect();
	    	if (status != Status.OK) {
	    		Log.e(TAG, "Cannot connect");
	    		return;
	    	}
	    	
	        status = mBus.registerSignalHandlers(this);
	    	if (status != Status.OK) {
	    		Log.e(TAG, "Cannot register signalHandler");
	    		return;
	    	}
	        
	    	mBusAttachmentState = BusAttachmentState.CONNECTED;
	    }  
	 
	    private boolean doDisconnect() {
	        Log.i(TAG, "doDisonnect()");
	    	assert(mBusAttachmentState == BusAttachmentState.CONNECTED);
	    	mBus.unregisterBusListener(mBusListener);
	    	mBus.disconnect();
			mBusAttachmentState = BusAttachmentState.DISCONNECTED;
	    	return true;
	    }
	    
	    
	    private void doRequestName() {
	        Log.i(TAG, "doRequestName()");
	    	
	        /*
	         * In order to request a name, the bus attachment must at least be
	         * connected.
	         */
	        int stateRelation = mBusAttachmentState.compareTo(BusAttachmentState.DISCONNECTED);
	    	assert (stateRelation >= 0);
	    	
	    	/*
	    	 * We depend on the user interface and model to work together to not
	    	 * get this process started until a valid name is set in the channel name.
	    	 */
	    	String wellKnownName =getWellKnownName();
	        Status status = mBus.requestName(wellKnownName, BusAttachment.ALLJOYN_REQUESTNAME_FLAG_DO_NOT_QUEUE);
	        if (status == Status.OK) {
	          	mHostChannelState = HostChannelState.NAMED;
	        } else {
	    		Log.e(TAG, "cannot request name");
	        }
	    }
	    
	    private void doReleaseName() {
	        Log.i(TAG, "doReleaseName()");
	        
	        /*
	         * In order to release a name, the bus attachment must at least be
	         * connected.
	         */
	        int stateRelation = mBusAttachmentState.compareTo(BusAttachmentState.DISCONNECTED);
	    	assert (stateRelation >= 0);
	    	assert(mBusAttachmentState == BusAttachmentState.CONNECTED || mBusAttachmentState == BusAttachmentState.DISCOVERING);
	    	
	    	/*
	    	 * We need to progress monotonically down the hosted channel states
	    	 * for sanity.
	    	 */
	    	assert(mHostChannelState == HostChannelState.NAMED);
	    	
	    	/*
	    	 * We depend on the user interface and model to work together to not
	    	 * change the name out from under us while we are running.
	    	 */
	    	String wellKnownName = getWellKnownName();

	    	/*
	    	 * There's not a lot we can do if the bus attachment refuses to release
	    	 * the name.  It is not a fatal error, though, if it doesn't.  This is
	    	 * because bus attachments can have multiple names.
	    	 */
	    	mBus.releaseName(wellKnownName);
	    	mHostChannelState = HostChannelState.IDLE;
	    }
	    
	    private void doBindSession() {
	        Log.i(TAG, "doBindSession()");
	        
	        Mutable.ShortValue contactPort = new Mutable.ShortValue(CONTACT_PORT);
	        SessionOpts sessionOpts = new SessionOpts(SessionOpts.TRAFFIC_MESSAGES, true, SessionOpts.PROXIMITY_ANY, SessionOpts.TRANSPORT_ANY);
	        
	        Status status = mBus.bindSessionPort(contactPort, sessionOpts, new SessionPortListener() {
	            /**
	             * This method is called when a client tries to join the session
	             * we have bound.  It asks us if we want to accept the client into
	             * our session.
	             *
	             * In the class documentation for the SessionPortListener note that
	             * it is a requirement for this method to be multithread safe.
	             * Since we never access any shared state, this requirement is met.
	             */
	        	public boolean acceptSessionJoiner(short sessionPort, String joiner, SessionOpts sessionOpts) {
	                Log.i(TAG, "SessionPortListener.acceptSessionJoiner(" + sessionPort + ", " + joiner + ", " + sessionOpts.toString() + ")");
	        	
	                /*
	        		 * Accept anyone who can get our contact port correct.
	        		 */
	        		if (sessionPort == CONTACT_PORT) {
	        			return true;
	        		}
	        		return false;
	            }
	            
	            /**
	             * If we return true in acceptSessionJoiner, we admit a new client
	             * into our session.  The session does not really exist until a 
	             * client joins, at which time the session is created and a session
	             * ID is assigned.  This method communicates to us that this event
	             * has happened, and provides the new session ID for us to use.
	             *
	             * In the class documentation for the SessionPortListener note that
	             * it is a requirement for this method to be multithread safe.
	             * Since we never access any shared state, this requirement is met.
	             * 
	             * See comments in joinSession for why the hosted chat interface is
	             * created here. 
	             */
	            public void sessionJoined(short sessionPort, int id, String joiner) {
	                Log.i(TAG, "SessionPortListener.sessionJoined(" + sessionPort + ", " + id + ", " + joiner + ")");
	                mHostSessionId = id;
	                SignalEmitter emitter = new SignalEmitter(mService, id, SignalEmitter.GlobalBroadcast.Off);
	                mHostInterface = emitter.getInterface(MyInterface.class);
	            }             
	        });
	        
	        if (status == Status.OK) {
	        	mHostChannelState = HostChannelState.BOUND;
	        } else {
	    		Log.e(TAG,"Unable to bind session contact port: (" + status + ")");
	        	return;
	        }
	    }
	    
	    public static enum UseChannelState {
	    	IDLE,	        /** There is no used chat channel */ 
	    	JOINED,		    /** The session for the channel has been successfully joined */
	    }
	    
	    /**
	     * The state of the AllJoyn components responsible for hosting an chat channel.
	     */
	    
	    abstract protected String getHostChannelName();
	    abstract protected String getChannelName();
	    
	    private void doJoinSession() {
	        Log.i(TAG, "doJoinSession()");
	        if (mHostChannelState != HostChannelState.IDLE) {
	        	if (getChannelName().equals(getHostChannelName())) {              
	        		mJoinedToSelf = true;
	                return;
	        	}
	        }
	       	/*
	    	 * We depend on the user interface and model to work together to provide
	    	 * a reasonable name.
	    	 */
	    	String wellKnownName = getWellKnownName();
	        
	        /*
	         * Since we can act as the host of a channel, we know what the other
	         * side is expecting to see.
	         */
	    	short contactPort = CONTACT_PORT;
	        SessionOpts sessionOpts = new SessionOpts(SessionOpts.TRAFFIC_MESSAGES, true, SessionOpts.PROXIMITY_ANY, SessionOpts.TRANSPORT_ANY);
	        Mutable.IntegerValue sessionId = new Mutable.IntegerValue();
	        
	        Status status = mBus.joinSession(wellKnownName, contactPort, sessionId, sessionOpts, new SessionListener() {
	            /**
	             * This method is called when the last remote participant in the 
	             * chat session leaves for some reason and we no longer have anyone
	             * to chat with.
	             *
	             * In the class documentation for the BusListener note that it is a
	             * requirement for this method to be multithread safe.  This is
	             * accomplished by the use of a monitor on the ChatApplication as
	             * exemplified by the synchronized attribute of the removeFoundChannel
	             * method there.
	             */
	            public void sessionLost(int sessionId) {
	                Log.i(TAG, "BusListener.sessionLost(" + sessionId + ")");
	            }
	        });
	        
	        if (status == Status.OK) {
	            Log.i(TAG, "doJoinSession(): use sessionId is " + mUseSessionId);
	        	mUseSessionId = sessionId.value;
	        } else {
	        	Log.e(TAG,"Unable to join session: (" + status + ")");
	        	return;
	        }
	        
	        SignalEmitter emitter = new SignalEmitter(mService, mUseSessionId, SignalEmitter.GlobalBroadcast.Off);
	        mMyInterface = emitter.getInterface(MyInterface.class);
	        
	    }
	    
	    /**
	     * This is the interface over which the chat messages will be sent.
	     */
	    MyInterface mMyInterface = null;
	    
	    /**
	     * Implementation of the functionality related to joining an existing
	     * remote session.
	     */
	    private void doLeaveSession() {
	        Log.i(TAG, "doLeaveSession()");
	        if (mJoinedToSelf == false) {
	        	mBus.leaveSession(mUseSessionId);
	        }
	        mUseSessionId = -1;
	        mJoinedToSelf = false;
	    }
	    
	    /**
	     * The session identifier of the "use" session that the application
	     * uses to talk to remote instances.  Set to -1 if not connectecd.
	     */
	    int mUseSessionId = -1;
	    
	    /**
	     * Implementation of the functionality related to sending messages out over
	     * an existing remote session.  Note that we always send all of the
	     * messages on the outbound queue, so there may be instances where this
	     * method is called and we find nothing to send depending on the races.
	     */
	    private void doSendMessages() {
	        Log.i(TAG, "doSendMessages()");
	        Point message;
	        while ((message = getPoint()) != null) {
	            Log.i(TAG, "doSendMessages(): sending message \"" + message + "\"");
	            /*
	             * If we are joined to a remote session, we send the message over
	             * the mChatInterface.  If we are implicityly joined to a session
	             * we are hosting, we send the message over the mHostChatInterface.
	             * The mHostChatInterface may or may not exist since it is created
	             * when the sessionJoined() callback is fired in the
	             * SessionPortListener, so we have to check for it.
	             */
				try {
					if (!mJoinedToSelf) {
						mMyInterface.MyMethod(message.x, message.y);
					}
				} catch (BusException ex) {
		    		Log.e(TAG,  "Bus exception while sending message: (" + ex + ")");
				}
	    	}
	    }
	    
	    abstract protected Point getPoint();

		int mHostSessionId = -1;
	    
	    /**
	     * A flag indicating that the application has joined a chat channel that
	     * it is hosting.  See the long comment in doJoinSession() for a
	     * description of this rather non-intuitively complicated case.
	     */
	    boolean mJoinedToSelf = false;
	    
	    /**
	     * This is the interface over which the chat messages will be sent in
	     * the case where the application is joined to a chat channel hosted
	     * by the application.  See the long comment in doJoinSession() for a
	     * description of this rather non-intuitively complicated case.
	     */
	    MyInterface mHostInterface = null;
	    
	    /**
	     * Implementation of the functionality related to un-binding a session port
	     * from an AllJoyn bus attachment.
	     */
	    private void doUnbindSession() {
	        Log.i(TAG, "doUnbindSession()");
	        
	        /*
	         * There's not a lot we can do if the bus attachment refuses to unbind
	         * our port.
	         */
	     	mBus.unbindSessionPort(CONTACT_PORT);
	     	mHostInterface = null;
	     	mHostChannelState = HostChannelState.NAMED;
	    }
	
	    public static enum BusAttachmentState {
	    	DISCONNECTED,	/** The bus attachment is not connected to the AllJoyn bus */ 
	    	CONNECTED,		/** The  bus attachment is connected to the AllJoyn bus */
	    	DISCOVERING		/** The bus attachment is discovering remote attachments hosting chat channels */
	    }
	    
	    /**
	     * The state of the AllJoyn bus attachment.
	     */
	    private BusAttachmentState mBusAttachmentState = BusAttachmentState.DISCONNECTED;
	    
	    /**
	     * Enumeration of the states of a hosted chat channel.  This lets us make a
	     * note to ourselves regarding where we are in the process of preparing
	     * and tearing down the AllJoyn pieces responsible for providing the chat
	     * service.  In order to be out of the IDLE state, the BusAttachment state
	     * must be at least CONNECTED.
	     */
	    public static enum HostChannelState {
	    	IDLE,	        /** There is no hosted chat channel */ 
	    	NAMED,		    /** The well-known name for the channel has been successfully acquired */
	    	BOUND,			/** A session port has been bound for the channel */
	    	ADVERTISED,	    /** The bus attachment has advertised itself as hosting an chat channel */
	    	CONNECTED       /** At least one remote device has connected to a session on the channel */
	    }
	    
	    /**
	     * The state of the AllJoyn components responsible for hosting an chat channel.
	     */
	    private HostChannelState mHostChannelState = HostChannelState.IDLE;
	 
	private static final String TAG = "MainService";


	public void init() {
		mBus  = new BusAttachment(MainApplication.PACKAGE_NAME, BusAttachment.RemoteMessage.Receive);
        Log.i(TAG, "onCreate()");
        startBusThread();
        addObserver(this);
        
        mBackgroundHandler.connect();
        mBackgroundHandler.startDiscovery();
 	}
	
   private BackgroundHandler mBackgroundHandler = null;
   
   /**
    * Since basically our whole reason for being is to spin up a thread to
    * handle long-lived remote operations, we provide thsi method to do so.
    */
   private void startBusThread() {
       HandlerThread busThread = new HandlerThread("BackgroundHandler");
       busThread.start();
   	   mBackgroundHandler = new BackgroundHandler(busThread.getLooper());
   }
   
   /**
    * When Android decides that our Service is no longer needed, we need to
    * tear down the thread that is servicing our long-lived remote operations.
	 * This method does so. 
    */
   private void stopBusThread() {
       mBackgroundHandler.exit();
   }
   
	public void destroy() {
        Log.i(TAG, "onDestroy()");
        mBackgroundHandler.disconnect();
        stopBusThread();
        deleteObserver(this);
 	}

	abstract protected void deleteObserver(MainService mainService);

	abstract protected void addObserver(MainService mainService);

}
